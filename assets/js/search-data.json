{
  
    
        "post0": {
            "title": "Super-charge Deep learning hyper-parameter search with Optuna",
            "content": "Introduction . Training machine learning sometimes involves various hyperparameter settings. Performing a hyperparameter search is an integral element in building machine learning models. It consists of attuning different sets of parameters to find the best settings for best model performance. It should be remarked that deep neural networks can involve many hyperparameter settings. Getting the best set parameters for such a high dimensional space might a challenging task. Opportunely, different strategies and tools can be used to simplify the process. This post will guide you on how to use Optuna for a hyper-parameter search using PyTorch and PyTorch lightning framework. The notebook with all the code for this post can be found on this colab link. . Optuna . Optuna is an open-source hyperparameter optimization framework. It automates the process of searching for optimal hyperparameter using Python conditionals, loops, and syntax. The optuna library offers efficiently hyper-parameter search in large spaces while pruning unpromising trials for faster results. It is also possible to run a hyperparameter search over multiple processes without modifying code. For a brief introduction of optuna, you can watch this video. . . The optuna optimization problem consists of three main building blocks; objective function, trial, and study. Let consider a simple optimisation problem: Suppose a rectangular garden is to be constructed using a rock wall as one side of the garden and wire fencing for the other three sides as shown in figure below (taken from this link/04%3A_Applications_of_Differentiation/4.07%3A_Optimization_Problems)). Given 500m of wire fencing, determine the dimensions that would create a garden of maximum area. What is the maximum area? . Let $x$ denote the side of the garden&#39;s side perpendicular to the rock wall, and $y$ indicates the side parallel to the rock wall. Then the area of the garden $A= x cdot y$. We want to find the maximum possible area subject to the constraint that the total fencing is 500m. The total amount of fencing used will be $2x+y$. Therefore, the constraint equation is $$ begin{aligned} 500 &amp; = 2x +y y &amp; = 500-2x A(x) &amp;= x cdot (500-2x) = 500x - 2x^2 end{aligned} . $$ . From equation above, $A(x) = 500x - 2x^2$ is an objective function, the function to be optimized. To maximize this function, we need to determine optimization constraints. We know that to construct a rectangular garden, we certainly need the lengths of both sides to be positive $y&gt;0$, and $x&gt;0$. Since $500 = 2x +y$ and $y&gt;0$ then $x&lt;250$. Therefore, we will try to determine the maximum value of A(x) for x over the open interval (0,50). . Optuna trial corresponds to a single execution of the objective function and is internally instantiated upon each invocation of the function. To obtain the parameters for each trial within a provided constraints the suggest method is used. . trial.suggest_uniform(&#39;x&#39;, 0, 250) . We can now code the objective function that be optimized for our problem. . def gardent_area(trial): x = trial.suggest_uniform(&#39;x&#39;, 0, 250) return (500*x - 2*x**2 ) . Once the objective function has been defined, the study object is used to start the optimization. The study is an optimization session, a set of trials. Optuna provide different sampler strategies such as Random Sampler and Tree-structured Parzen Estimator (TPE) sampler. A sampler has the responsibility to determine the parameter values to be evaluated in a trial. By default, Optuna uses TPE sampler, which is a form of Bayesian Optimization. The TPE provides a more efficient search than a random sampler search by choosing points closer to past good results. It possible to add a custom sampler as described in this link Let create a study and start the optimization process. . ##collapse import optuna def gardent_area(trial): x = trial.suggest_uniform(&#39;x&#39;, 0, 250) return (500*x - 2*x**2 ) study = optuna.create_study(study_name=&quot;garden&quot;, direction=&quot;maximize&quot;) study.optimize(gardent_area, n_trials=20) print(study.best_params) print(study.best_value) . [I 2020-06-22 22:52:09,728] Finished trial#0 with value: 10151.49608988398 with parameters: {&#39;x&#39;: 22.290448569483033}. Best is trial#0 with value: 10151.49608988398. [I 2020-06-22 22:52:09,773] Finished trial#1 with value: 17318.662620758565 with parameters: {&#39;x&#39;: 208.46058165158396}. Best is trial#1 with value: 17318.662620758565. [I 2020-06-22 22:52:09,823] Finished trial#2 with value: 27521.441691493033 with parameters: {&#39;x&#39;: 168.17729906158428}. Best is trial#2 with value: 27521.441691493033. [I 2020-06-22 22:52:09,895] Finished trial#3 with value: 13298.982948674558 with parameters: {&#39;x&#39;: 219.7391604652623}. Best is trial#2 with value: 27521.441691493033. [I 2020-06-22 22:52:09,963] Finished trial#4 with value: 28781.742638896496 with parameters: {&#39;x&#39;: 89.86983232958102}. Best is trial#4 with value: 28781.742638896496. [I 2020-06-22 22:52:10,029] Finished trial#5 with value: 24178.31616974594 with parameters: {&#39;x&#39;: 65.53705426799789}. Best is trial#4 with value: 28781.742638896496. [I 2020-06-22 22:52:10,093] Finished trial#6 with value: 30988.976474053892 with parameters: {&#39;x&#39;: 113.5758255014617}. Best is trial#6 with value: 30988.976474053892. [I 2020-06-22 22:52:10,157] Finished trial#7 with value: 13014.154069127257 with parameters: {&#39;x&#39;: 29.51218420428514}. Best is trial#6 with value: 30988.976474053892. [I 2020-06-22 22:52:10,213] Finished trial#8 with value: 26495.19819885987 with parameters: {&#39;x&#39;: 76.24140177804468}. Best is trial#6 with value: 30988.976474053892. [I 2020-06-22 22:52:10,284] Finished trial#9 with value: 7902.5922494895785 with parameters: {&#39;x&#39;: 233.0449160083676}. Best is trial#6 with value: 30988.976474053892. [I 2020-06-22 22:52:10,348] Finished trial#10 with value: 30674.733702364072 with parameters: {&#39;x&#39;: 141.959750847756}. Best is trial#6 with value: 30988.976474053892. [I 2020-06-22 22:52:10,398] Finished trial#11 with value: 29435.27370289011 with parameters: {&#39;x&#39;: 155.12246916431226}. Best is trial#6 with value: 30988.976474053892. [I 2020-06-22 22:52:10,466] Finished trial#12 with value: 31245.068909091035 with parameters: {&#39;x&#39;: 126.57020554529808}. Best is trial#12 with value: 31245.068909091035. [I 2020-06-22 22:52:10,578] Finished trial#13 with value: 30588.77344891283 with parameters: {&#39;x&#39;: 106.81722585677348}. Best is trial#12 with value: 31245.068909091035. [I 2020-06-22 22:52:10,660] Finished trial#14 with value: 24240.253402783623 with parameters: {&#39;x&#39;: 184.20197039464304}. Best is trial#12 with value: 31245.068909091035. [I 2020-06-22 22:52:10,821] Finished trial#15 with value: 31159.747247230775 with parameters: {&#39;x&#39;: 118.28238313204648}. Best is trial#12 with value: 31245.068909091035. [I 2020-06-22 22:52:10,868] Finished trial#16 with value: 31178.10743621456 with parameters: {&#39;x&#39;: 130.99552181988523}. Best is trial#12 with value: 31245.068909091035. [I 2020-06-22 22:52:10,948] Finished trial#17 with value: 21092.127701120175 with parameters: {&#39;x&#39;: 53.733344757594296}. Best is trial#12 with value: 31245.068909091035. [I 2020-06-22 22:52:10,999] Finished trial#18 with value: 30900.324237077977 with parameters: {&#39;x&#39;: 138.2226276307325}. Best is trial#12 with value: 31245.068909091035. [I 2020-06-22 22:52:11,089] Finished trial#19 with value: 24068.372267603627 with parameters: {&#39;x&#39;: 184.92339998863707}. Best is trial#12 with value: 31245.068909091035. . {&#39;x&#39;: 126.57020554529808} 31245.068909091035 . Once the study is completed, you can get the best parameters using study.best_params and study.best_value will give you the best value. . Hyper-param search for deep neural net . Suppose we want to build MLP classifier to recognize handwritten digits using the MNIST dataset. We will first build a pytorch MLP model with the following default parameters . hparams = {&quot;in_size&quot;: 28*28, &quot;hidden_size&quot;:128, &quot;out_size&quot;:10, &quot;layer_size&quot;:5, &quot;dropout&quot;:0.2} . #collapse import torch import torch.nn as nn from torch.nn import functional as F class MLP(nn.Module): def __init__(self, hparams): super().__init__() layers = [hparams[&#39;in_size&#39;], hparams[&#39;hidden_size&#39;]]+[hparams[&#39;hidden_size&#39;]*2**i for i in range(hparams[&#39;layer_size&#39;]-1)] self.layers = [] for i in range(len(layers)-1): layer = nn.Linear(layers[i], layers[i+1]) self.layers.append(layer) self.layers.append(nn.ReLU()) if i!=0: self.layers.append(nn.Dropout(hparams[&#39;dropout&#39;])) out_layer = nn.Linear(layers[-1], hparams[&#39;out_size&#39;]) self.layers.append(out_layer) ##initilize weights for layer in self.layers: if isinstance(layer, nn.Linear): nn.init.xavier_uniform_(layer.weight) self.mlp = nn.Sequential(*self.layers) def forward(self, x): return self.mlp(x) . . #collapse hparams = {&quot;in_size&quot;: 28*28, &quot;hidden_size&quot;:128, &quot;out_size&quot;:10, &quot;layer_size&quot;:5, &quot;dropout&quot;:0.2} model = MLP(hparams) model . . MLP( (mlp): Sequential( (0): Linear(in_features=784, out_features=128, bias=True) (1): ReLU() (2): Linear(in_features=128, out_features=128, bias=True) (3): ReLU() (4): Dropout(p=0.2, inplace=False) (5): Linear(in_features=128, out_features=256, bias=True) (6): ReLU() (7): Dropout(p=0.2, inplace=False) (8): Linear(in_features=256, out_features=512, bias=True) (9): ReLU() (10): Dropout(p=0.2, inplace=False) (11): Linear(in_features=512, out_features=1024, bias=True) (12): ReLU() (13): Dropout(p=0.2, inplace=False) (14): Linear(in_features=1024, out_features=10, bias=True) ) ) . For the above MLP model, we need to specify the following parameters hidden size, dropout, and number of linear layers. The critical question is, how do we pick these parameters. We will use optuna to search for optimal parameters that will give us an excellent performance. First, we will create a PyTorch lightning model that will provide the structure for organizing the fundamentals component of any machine learning project. These elements include the data, architecture or model, optimizer, loss function, training, and evaluation step. Since we fine defined our MLP, we go ahead and create a PyTorch lightning module. . #collapse from torch.utils.data import DataLoader, random_split from torchvision.datasets import MNIST import os from torchvision import datasets, transforms import pytorch_lightning as pl import pytorch_lightning.metrics.functional as metrics class MLPIL(pl.LightningModule): def __init__(self, hparams): super().__init__() self.hparams = hparams self.model = MLP(hparams) def forward(self, x): return self.model(x) def training_step(self, batch, batch_idx): x, y = batch logits = self(x.reshape(x.size(0), -1)) loss = F.cross_entropy(logits, y) acc = metrics.accuracy(torch.max(logits, 1)[1], y) logs = {&#39;loss&#39;: loss, &quot;tra_acc&quot;:acc} return {&#39;loss&#39;: loss, &#39;log&#39;: logs} def validation_step(self, batch, batch_idx): x, y = batch logits = self(x.reshape(x.size(0), -1)) loss = F.cross_entropy(logits, y) acc = metrics.accuracy(torch.max(logits, 1)[1], y) logs = {&#39;val_loss&#39;: loss, &quot;val_acc&quot;:acc} return logs def validation_epoch_end(self, outputs): # OPTIONAL avg_loss = torch.stack([x[&#39;val_loss&#39;] for x in outputs]).mean() avg_acc = torch.stack([x[&#39;val_acc&#39;] for x in outputs]).mean() logs = {&#39;val_loss&#39;: avg_loss, &quot;val_acc&quot;:avg_acc} return {&#39;log&#39;:logs} def train_dataloader(self): # REQUIRED return DataLoader(MNIST(os.getcwd(), train=True, download=True, transform=transforms.ToTensor()), batch_size=self.hparams[&quot;batch_size&quot;], num_workers=4) def val_dataloader(self): # OPTIONAL return DataLoader(MNIST(os.getcwd(), train=False, download=True, transform=transforms.ToTensor()), batch_size=self.hparams[&quot;batch_size&quot;], num_workers=4) def configure_optimizers(self): optimizer = torch.optim.SGD(self.model.parameters(), lr=self.hparams[&#39;learning_rate&#39;], momentum=self.hparams[&#39;momentum&#39;], nesterov=self.hparams[&#39;nesterov&#39;], weight_decay=self.hparams[&#39;weight_decay&#39;]) return optimizer . . To learn the parameters of the MLP we will use Stochastic Gradient Descent Optimizer (SGD) optimizer. The SGD has several other hper-parameters such as learning rate which we can also optimize. . pyhon optimizer = torch.optim.SGD(self.model.parameters(), lr=self.hparams[&#39;learning_rate&#39;], momentum=self.hparams[&#39;momentum&#39;], nesterov=self.hparams[&#39;nesterov&#39;], weight_decay=self.hparams[&#39;weight_decay&#39;]) . Thus the SGD optimizer will add four additional parameters. We can also treat the batch size as hyper-parameter to optimize. We will have the following set of parameters to optimizers. . default_params = {&quot;in_size&quot;: 28*28, &quot;hidden_size&quot;:128, &quot;out_size&quot;:10, &quot;layer_size&quot;:5, &quot;dropout&quot;:0.2, &quot;batch_size&quot;:32, &#39;learning_rate&#39;:1e-3, &#39;momentum&#39;:0.9, &#39;nesterov&#39;: True, &#39;weight_decay&#39;:1e-5, &#39;epochs&#39;:2} . Defining the hyperparameters and objective function to be optimized . Since we know all the parameters that we want to optimize, we will use the optuna suggest to define a search space for each hyperparameter that we want to tune. Optuna supports a variety of suggests which can be used to optimize floats, integers, or discrete categorical values. Numerical values such as learning rate can be suggested using a logarithmic scale. . def get_search_space(trial, default_params): lr_param = {&#39;learning_rate&#39;: trial.suggest_loguniform(&quot;learning_rate&quot;, 1e-4, 1e-3)} default_params.update(lr_param) wdecay_param = {&#39;weight_decay&#39;: trial.suggest_loguniform(&#39;weight_decay&#39;, 1e-5, 1e-2)} default_params.update(wdecay_param) hidden_size_param={&#39;hidden_size&#39;: trial.suggest_categorical(&quot;hidden_size&quot;, [8*2**i for i in range(6)])} default_params.update(hidden_size_param) batch_size_param={&#39;hidden_size&#39;: trial.suggest_categorical(&quot;batch_size&quot;, [16, 32, 64, 128])} default_params.update(hidden_size_param) layer_size_param={&quot;layer_size&quot;: trial.suggest_int(&quot;layer_size&quot;, 2, 5)} default_params.update(layer_size_param) dropout_param={&quot;dropout&quot;: trial.suggest_float(&#39;dropout&#39;, 0.1, .5)} default_params.update(dropout_param) momentum_param = {&#39;momentum&#39;: trial.suggest_float(&#39;momentum&#39;, 0.8, 1.0)} default_params.update(momentum_param) nest_param={&#39;nesterov&#39;:trial.suggest_categorical(&quot;nesterov&quot;, [False, True])} default_params.update(nest_param) return default_params . To create an objective function, we use the trainer module within PyTorch lightning with the default TensorBoard logger. The trainer will return the validation score. Optuna will use this score to evaluate the performance of the hyperparameters and decide where to sample in upcoming trials. . #collapse from pathlib import Path from optuna.integration import PyTorchLightningPruningCallback DIR = Path(os.getcwd()) MODEL_DIR = DIR/ &quot;MLP&quot; MODEL_DIR.mkdir(parents=True, exist_ok=True) print(f&quot;now run `tensorboard --logdir {MODEL_DIR}&quot;) class DictLogger(pl.loggers.TensorBoardLogger): &quot;&quot;&quot;PyTorch Lightning `dict` logger.&quot;&quot;&quot; # see https://github.com/PyTorchLightning/pytorch-lightning/blob/50881c0b31/pytorch_lightning/logging/base.py def __init__(self, *args, **kwargs): super().__init__(*args, **kwargs) self.metrics = [] def log_metrics(self, metrics, step=None): super().log_metrics(metrics, step=step) self.metrics.append(metrics) . . now run `tensorboard --logdir /Users/sambaiga/Documents/sambaiga/_notebooks/MLP . In addition to sampling strategies, Optuna provides a mechanism to automatically stops unpromising trials at the early stages of the training. This allows computing time to be used for tests that show more potential. This feature is called pruning, and it is a form of automated early-stopping. The PyTorchLightingPruningCallBack provides integration Optuna pruning function to PyTorch lightning. Pruner using the median stopping rule. . #collapse default_params = {&quot;in_size&quot;: 28*28, &quot;hidden_size&quot;:128, &quot;out_size&quot;:10, &quot;layer_size&quot;:5, &quot;dropout&quot;:0.2, &quot;batch_size&quot;:32, &#39;learning_rate&#39;:1e-3, &#39;momentum&#39;:0.9, &#39;nesterov&#39;: True, &#39;weight_decay&#39;:1e-5, &#39;epochs&#39;:50} def objective(trial=None): if trial is not None: hparams = get_search_space(trial, default_params) early_stopping = PyTorchLightningPruningCallback(trial, monitor=&#39;val_acc&#39;) checkpoint_callback = pl.callbacks.ModelCheckpoint( os.path.join(MODEL_DIR, &quot;trial_{}&quot;.format(trial.number)), monitor=&quot;val_acc&quot; ) logger = DictLogger(MODEL_DIR, version=trial.number) else: early_stopping = pl.callbacks.EarlyStopping(monitor=&#39;val_acc&#39;, min_delta=1e-4, patience=20, mode=&quot;max&quot;) logger = DictLogger(MODEL_DIR) trainer = pl.Trainer( logger = logger, checkpoint_callback=checkpoint_callback, max_epochs=10, gpus=1 if torch.cuda.is_available() else None, early_stop_callback=early_stopping ) model = MLPIL(hparams) trainer.fit(model) if trial is not None: return logger.metrics[-1][&#39;val_acc&#39;] . . To start the optimization, we create a study object and pass the objective function to method optimize() as follows. . ##collapse import optuna def run_study(num_trials=10): #Activate the pruning feature. `MedianPruner` stops unpromising # Set up the median stopping rule as the pruning condition pruner = optuna.pruners.MedianPruner() study = optuna.create_study(pruner=pruner, direction=&#39;maximize&#39;) study.optimize(objective, n_trials=num_trials) print(&quot;Number of finished trials: {}&quot;.format(len(study.trials))) print(&quot;Best trial:&quot;) trial = study.best_trial print(&quot; Value: {}&quot;.format(trial.value)) print(&quot; Params: &quot;) for key, value in trial.params.items(): print(&quot; {}: {}&quot;.format(key, value)) return study . To turn on the pruning feature, we hve to set up the the pruning condition which periodically monitors the intermediate objective values. Several pruning condistions such as Hyperband, Successive Halving exists as decribed in optuna documentation. For this example we will use the MedianPruner() which prune if the trial’s best intermediate result is worse than median of intermediate results of previous trials at the same step. . #collapse study = run_study(num_trials=10) . . GPU available: False, used: False TPU available: False, using: 0 TPU cores | Name | Type | Params - 0 | model | MLP | 817 K . . [I 2020-06-22 23:36:32,489] Finished trial#0 with value: 0.763079047203064 with parameters: {&#39;learning_rate&#39;: 0.0002781761413312715, &#39;weight_decay&#39;: 0.00026786709389757784, &#39;hidden_size&#39;: 128, &#39;batch_size&#39;: 16, &#39;layer_size&#39;: 5, &#39;dropout&#39;: 0.4475426537245917, &#39;momentum&#39;: 0.8343662356211846, &#39;nesterov&#39;: True}. Best is trial#0 with value: 0.763079047203064. GPU available: False, used: False TPU available: False, using: 0 TPU cores | Name | Type | Params - 0 | model | MLP | 286 K [I 2020-06-22 23:38:10,138] Finished trial#1 with value: 0.8695088028907776 with parameters: {&#39;learning_rate&#39;: 0.00019459451111337528, &#39;weight_decay&#39;: 0.0008316437322277936, &#39;hidden_size&#39;: 128, &#39;batch_size&#39;: 16, &#39;layer_size&#39;: 4, &#39;dropout&#39;: 0.30811559721491616, &#39;momentum&#39;: 0.8792675991877269, &#39;nesterov&#39;: True}. Best is trial#1 with value: 0.8695088028907776. GPU available: False, used: False TPU available: False, using: 0 TPU cores | Name | Type | Params - 0 | model | MLP | 6 K . . [I 2020-06-22 23:39:32,721] Finished trial#2 with value: 0.5426318049430847 with parameters: {&#39;learning_rate&#39;: 0.00031379768467785276, &#39;weight_decay&#39;: 0.00024206467053167096, &#39;hidden_size&#39;: 8, &#39;batch_size&#39;: 128, &#39;layer_size&#39;: 3, &#39;dropout&#39;: 0.4051284289161241, &#39;momentum&#39;: 0.8700648073603755, &#39;nesterov&#39;: True}. Best is trial#1 with value: 0.8695088028907776. GPU available: False, used: False TPU available: False, using: 0 TPU cores | Name | Type | Params - 0 | model | MLP | 16 K . . [I 2020-06-22 23:41:03,403] Finished trial#3 with value: 0.7521964907646179 with parameters: {&#39;learning_rate&#39;: 0.0009969827342691411, &#39;weight_decay&#39;: 0.00191834042067662, &#39;hidden_size&#39;: 16, &#39;batch_size&#39;: 64, &#39;layer_size&#39;: 4, &#39;dropout&#39;: 0.4199071669462878, &#39;momentum&#39;: 0.8583730620569984, &#39;nesterov&#39;: False}. Best is trial#1 with value: 0.8695088028907776. GPU available: False, used: False TPU available: False, using: 0 TPU cores | Name | Type | Params - 0 | model | MLP | 16 K [I 2020-06-22 23:42:18,938] Finished trial#4 with value: 0.9208266735076904 with parameters: {&#39;learning_rate&#39;: 0.0003222124173376937, &#39;weight_decay&#39;: 0.0002461730007892341, &#39;hidden_size&#39;: 16, &#39;batch_size&#39;: 128, &#39;layer_size&#39;: 4, &#39;dropout&#39;: 0.27574042289278133, &#39;momentum&#39;: 0.9910653091313444, &#39;nesterov&#39;: True}. Best is trial#4 with value: 0.9208266735076904. GPU available: False, used: False TPU available: False, using: 0 TPU cores . . | Name | Type | Params - 0 | model | MLP | 3 M [I 2020-06-22 23:47:26,157] Finished trial#5 with value: 0.9458865523338318 with parameters: {&#39;learning_rate&#39;: 0.0009011149211580522, &#39;weight_decay&#39;: 0.008235695017360493, &#39;hidden_size&#39;: 256, &#39;batch_size&#39;: 16, &#39;layer_size&#39;: 5, &#39;dropout&#39;: 0.13696254402480412, &#39;momentum&#39;: 0.9454761908726577, &#39;nesterov&#39;: True}. Best is trial#5 with value: 0.9458865523338318. . . GPU available: False, used: False TPU available: False, using: 0 TPU cores | Name | Type | Params - 0 | model | MLP | 817 K . . [I 2020-06-22 23:49:29,151] Finished trial#6 with value: 0.7892372012138367 with parameters: {&#39;learning_rate&#39;: 0.00011431229408656762, &#39;weight_decay&#39;: 9.658630631397371e-05, &#39;hidden_size&#39;: 128, &#39;batch_size&#39;: 16, &#39;layer_size&#39;: 5, &#39;dropout&#39;: 0.4476176051738697, &#39;momentum&#39;: 0.9355278762575644, &#39;nesterov&#39;: True}. Best is trial#5 with value: 0.9458865523338318. GPU available: False, used: False TPU available: False, using: 0 TPU cores | Name | Type | Params - 0 | model | MLP | 118 K [I 2020-06-22 23:50:47,697] Finished trial#7 with value: 0.8660143613815308 with parameters: {&#39;learning_rate&#39;: 0.00011985939874632534, &#39;weight_decay&#39;: 0.00013574996304822177, &#39;hidden_size&#39;: 128, &#39;batch_size&#39;: 128, &#39;layer_size&#39;: 2, &#39;dropout&#39;: 0.43912042347804847, &#39;momentum&#39;: 0.8847775912911807, &#39;nesterov&#39;: False}. Best is trial#5 with value: 0.9458865523338318. GPU available: False, used: False TPU available: False, using: 0 TPU cores | Name | Type | Params - 0 | model | MLP | 817 K . . [I 2020-06-22 23:52:38,352] Finished trial#8 with value: 0.7717651724815369 with parameters: {&#39;learning_rate&#39;: 0.00021577654778061675, &#39;weight_decay&#39;: 0.00010839860995588048, &#39;hidden_size&#39;: 128, &#39;batch_size&#39;: 64, &#39;layer_size&#39;: 5, &#39;dropout&#39;: 0.32940522064176114, &#39;momentum&#39;: 0.8292747404960318, &#39;nesterov&#39;: False}. Best is trial#5 with value: 0.9458865523338318. GPU available: False, used: False TPU available: False, using: 0 TPU cores | Name | Type | Params - 0 | model | MLP | 6 K [I 2020-06-22 23:53:47,373] Finished trial#9 with value: 0.5784744620323181 with parameters: {&#39;learning_rate&#39;: 0.00034234441557670246, &#39;weight_decay&#39;: 7.769001540971277e-05, &#39;hidden_size&#39;: 8, &#39;batch_size&#39;: 64, &#39;layer_size&#39;: 3, &#39;dropout&#39;: 0.3206051108604173, &#39;momentum&#39;: 0.8964296642692322, &#39;nesterov&#39;: False}. Best is trial#5 with value: 0.9458865523338318. . Number of finished trials: 10 Best trial: Value: 0.9458865523338318 Params: learning_rate: 0.0009011149211580522 weight_decay: 0.008235695017360493 hidden_size: 256 batch_size: 16 layer_size: 5 dropout: 0.13696254402480412 momentum: 0.9454761908726577 nesterov: True . After the study is completed, we can export trials as a pandas data frame. This provides various features to analyze studies. It is also useful to draw a histogram of objective values and to export trials as a CSV file. . df = study.trials_dataframe() . Visualize study . import pandas as pd df = study.trials_dataframe() . df . number value datetime_start datetime_complete duration params_batch_size params_dropout params_hidden_size params_layer_size params_learning_rate params_momentum params_nesterov params_weight_decay state . 0 0 | 0.763079 | 2020-06-22 23:33:43.417440 | 2020-06-22 23:36:32.488858 | 00:02:49.071418 | 16 | 0.447543 | 128 | 5 | 0.000278 | 0.834366 | True | 0.000268 | COMPLETE | . 1 1 | 0.869509 | 2020-06-22 23:36:32.492923 | 2020-06-22 23:38:10.137740 | 00:01:37.644817 | 16 | 0.308116 | 128 | 4 | 0.000195 | 0.879268 | True | 0.000832 | COMPLETE | . 2 2 | 0.542632 | 2020-06-22 23:38:10.139134 | 2020-06-22 23:39:32.720646 | 00:01:22.581512 | 128 | 0.405128 | 8 | 3 | 0.000314 | 0.870065 | True | 0.000242 | COMPLETE | . 3 3 | 0.752196 | 2020-06-22 23:39:32.722697 | 2020-06-22 23:41:03.401500 | 00:01:30.678803 | 64 | 0.419907 | 16 | 4 | 0.000997 | 0.858373 | False | 0.001918 | COMPLETE | . 4 4 | 0.920827 | 2020-06-22 23:41:03.405764 | 2020-06-22 23:42:18.937616 | 00:01:15.531852 | 128 | 0.275740 | 16 | 4 | 0.000322 | 0.991065 | True | 0.000246 | COMPLETE | . 5 5 | 0.945887 | 2020-06-22 23:42:18.939922 | 2020-06-22 23:47:26.156283 | 00:05:07.216361 | 16 | 0.136963 | 256 | 5 | 0.000901 | 0.945476 | True | 0.008236 | COMPLETE | . 6 6 | 0.789237 | 2020-06-22 23:47:26.158874 | 2020-06-22 23:49:29.150356 | 00:02:02.991482 | 16 | 0.447618 | 128 | 5 | 0.000114 | 0.935528 | True | 0.000097 | COMPLETE | . 7 7 | 0.866014 | 2020-06-22 23:49:29.152156 | 2020-06-22 23:50:47.697022 | 00:01:18.544866 | 128 | 0.439120 | 128 | 2 | 0.000120 | 0.884778 | False | 0.000136 | COMPLETE | . 8 8 | 0.771765 | 2020-06-22 23:50:47.699384 | 2020-06-22 23:52:38.352413 | 00:01:50.653029 | 64 | 0.329405 | 128 | 5 | 0.000216 | 0.829275 | False | 0.000108 | COMPLETE | . 9 9 | 0.578474 | 2020-06-22 23:52:38.354018 | 2020-06-22 23:53:47.372384 | 00:01:09.018366 | 64 | 0.320605 | 8 | 3 | 0.000342 | 0.896430 | False | 0.000078 | COMPLETE | . study.best_params . {&#39;learning_rate&#39;: 0.0009011149211580522, &#39;weight_decay&#39;: 0.008235695017360493, &#39;hidden_size&#39;: 256, &#39;batch_size&#39;: 16, &#39;layer_size&#39;: 5, &#39;dropout&#39;: 0.13696254402480412, &#39;momentum&#39;: 0.9454761908726577, &#39;nesterov&#39;: True} . optuna.visualization.plot_contour(study) . optuna.visualization.plot_optimization_history(study) . optuna.visualization.plot_param_importances(study) . /usr/local/lib/python3.7/site-packages/optuna/_experimental.py:63: ExperimentalWarning: plot_param_importances is experimental (supported from v1.5.0). The interface can change in the future. /usr/local/lib/python3.7/site-packages/optuna/_experimental.py:63: ExperimentalWarning: get_param_importances is experimental (supported from v1.3.0). The interface can change in the future. /usr/local/lib/python3.7/site-packages/optuna/_experimental.py:84: ExperimentalWarning: MeanDecreaseImpurityImportanceEvaluator is experimental (supported from v1.5.0). The interface can change in the future. . import shutil shutil.rmtree(MODEL_DIR) .",
            "url": "https://sambaiga.github.io/sambaiga/deep%20learning/machine%20learning/2020/06/22/hyper-search.html",
            "relUrl": "/deep%20learning/machine%20learning/2020/06/22/hyper-search.html",
            "date": " • Jun 22, 2020"
        }
        
    
  
    
        ,"post1": {
            "title": "AI4EO-An Opportunity for Computation Sustainability",
            "content": "Introduction . Computational Sustainability focuses on developing computational models, methods, and tools to help policymakers design more effective solutions and policies for sustainable development. The advancement of Information and Communication Technologies (ICT), particularly Earth Observation (EO) and Artificial intelligence (AI) offer prospects of addressing sustainability challenges. A more in-depth explanation about the above project can be viewed in this video: . Earth observations (EO) are data and information about the planet’s physical, chemical, and biological systems. It involves the collection, analysis, and presentation about the status of, and changes in, the natural and human-made environment. The most common sources of EO data include drones, land stations, and satellites. While drones capture high-resolution images on a small scale, satellites generate growing amounts of multi-resolution and multi-bands imagery and other data sources for the whole Earth. These data could be used to create all kinds of different products so that businesses, scientists, policymakers, and even everyday citizens can understand the past, present, and future trends in the Earth systems. Figure below shows multiband imagery from satellites by the electromagnetic. . On the other hand, AI is an area of computer science devoted to developing systems that can learn (from data) to make decisions and predictions within specific contexts. Indeed, AI technology can extract more in-depth insights from datasets than other techniques. Lately, AI has been used with success in solving complex problems in several domains such as machine translation, computer vision, autonomous cars, to mention a few. Machine learning and particularly computer vision models provide explicitly useful and practical approaches for analyzing and extracting relevant information from EO imagery data. Deep learning models and especially Convolution Neural Networks (CNNs) have proven effective in several computer vision tasks such as object detection, classification, and video processing, image generations, and image captioning, to mention a few. These models could be applied to detect and classify objects from complex EO imagery at a larger scale. Figure 2 presents AI capability for object detection and using computer vision techniques for multiband satellite images. This image has been taken from here). . Applying these techniques to EO data will make it easy to efficiently automate the recognition of known and unknown patterns at large-scale. This is likely to reveal useful insights and opportunities for addressing sustainability challenges. For example, AI models could be applied to perform automated change detection, crop mapping, and yield estimation from high-resolution imagery in a larger-scale. The fusion of EO data and other data sources such as geo-referenced, demographics, and social-network data can be used to facilitate the more targeted developmental challenge. For instance, it has been demonstrated that the AI model can be used to predict the poverty level by analyzing satellite imagery, night lights, and demographic data. . EO data sources . There are many EO data sources made available recently. These data sources offer virtual visualization of any location on earth with resolution ranging from 5 centimeters to 120 meters depending on the instruments of satellites, airbus, or drones. The data sources are published as public or commercial data sources. . Public EO data providers . The EO puplic data providers are public service framework that allows full, free and open access to all data collected. Copernicus and Landsat are the famous and largest public satellite data providers. Landsat s one of the world’s largest satellite image providers. It is a joint program of the National Aeronautics and Space Administration (NASA) and the United States Geological Survey (USGS). It provides access to satellites of the Landsat family, which have access over the archival of 50 years of earth data. Landsat satellites collect data on the forests, farms, urban areas, and water sources, generating the longest continuous record. The freely available information is used to understand environmental change better, manage agricultural practices, allocate scarce water resources, monitor the extent and health of forests and respond to natural disasters, and more. Data can be accessed using LandsLook Viewer, USGS GloVis, Earth Explorer, Free Web-Enabled Landsat Data (WELD). More information is available here. . Copernicus is managed by the Europe Unions EO program and collect data from a constellation of 6 families of satellites, known as Sentinels. Each Sentinel mission focuses on different but interrelated aspects of EO, including Atmospheric monitoring (Sentinels 4 and 5), Marine environment monitoring (Sentinel-3), Land monitoring (Sentinel-2), Climate Change and Emergency management. Currently Copernicus produces 12 terabytes per day of data for the 6 families of satellites, known as “Sentinels.” The data are open access and can be freely downloaded using [Copernicus Open Access Hub]. A summary of Copernicus program can found in this video . Commercial data providers . The commercial satellite imagery providers provide access to data with high resolution with 3 centimeters to 10 meters. These services are paid and have good archival imagery. The most popular commercial EO imagery providers include; Planet Labs, DigitalGlobe and Airbus. . Planet Labs provides access to a wide range of satellite data. It provides access to SkySAT families and RapidEye satellites. With 120+ satellites in orbit, Planet can image anywhere on Earth’s landmass daily, at 3 - 5-meter resolution. Planet processes and delivers imagery quickly and efficiently. Planet’s platform downloads and processes 11+ TB of data daily, enabling customers to build and run analytics at scale. Users can access Planet’s data, using the paid planet API. Nevertheless, university researchers, academics, and scientists apply for free access as decribed in this link. . The DigitalGlobe is similar to Planet Labs and provides data access to a full range constellation of satellites in orbit. It provides access to EarlyBird-1, IKONOS, QuickBird, GeoEye-1, a family of WorldView satellites. It offers a high resolution of up to 30cm, showing crisp details, satellite imagery, geospatial information, and location-based intelligence. Recently, DigitalGlobe has started providing 0.4m resolution imagery today, which is one of the best in the business. . On the other hand, the Airbus, with Pleiades and SPOT missions, provide very high-resolution multispectral twin satellites with 0.5 meters and 1.5-meter resolution, respectively. These imagery data are particularly suitable for emergency response and up-to daily change detection. . AI ready EO datasets . Building ML applications for EO requires access to both EO data and their ground truth. Creating such a data-set is time-consuming and costly. As a result different organisations provide ready-to-use EO dataset which allow ML and GIS researchers and other stakeholders to build and test their ML application specific to EO. Radiant MLHub and Spacenet are the two notable EO training data providers. Radiant MLHub is an open library for geospatial training data to advance machine learning applications on EO. It hosts open training datasets generated by Radiant Earth Foundation’s team as well as other training data catalogs contributed by Radiant Earth’s partners. The data provided by Radiant MLHub are stored using a SpatioTemporal Asset Catalog (STAC) compliant catalog and exposed through a standard API. These data are open to anyone to use. It also free stores, register and share your dataset. . The Spacenet, on the other hand, provides access to high-quality geospatial data for developers, researchers, and startups with a specific focus on the four open-source key pillars: data, challenges, algorithms, and tools. It also hosts challenges that focus on applying advanced machine learning techniques to solve difficult mapping challenges. The SpaceNet Dataset is hosted as an Amazon Web Services (AWS) Public Dataset, which is open for geospatial machine learning research. The dataset consists of well-annotated and very high-resolution satellite imagery with foundational mapping features such as building footprints or road networks. . Kaggle, a world’s largest data science community with powerful tools and resources, is another source of EO training datasets which host several machine learning challenges EO imagery. This challenges includes Dstl Satellite Imagery Feature Detection, Airbus Ship Detection Challenge and Draper Satellite Image Chronology to mention a few. . . API for accessing EO data. . Despite the availability of free and commercial satellite imagery, it is somehow challenging to directly download and use these data. Accessing these data requires one to have expertise in satellite imagery. Several API solutions that make it easy to access, download, and use satellite imagery from different sources have been developed to address these challenges. Sentinel Hub API is one of the easily available data API. . Sentinel Hub API makes satellite data from Sentinel, Landsat, and other Earth observation imagery easily accessible via easy-to-integrate web services. The API allows users to integrate satellite data either into their applications. To this end, Sentinel-hub offers several plugins such as sentinelhub-python, Sentinelhub-js, Sentinel Hub QGIS and EO Browser which is is a search tool for Sentinel-2 and Landsat 5,7,8 satellite imagery. Sentinelhub-js offer seamless integration of Sentinel Hub and other similar EO web services in web or node.js. This allows web developers to access remote sensing data quickly and to integrate it with their applications. On the other hand, the sentinel hub-python enables users to seamlessly make requests from Sentinel Hub OGC web services, download, and process images within their Python scripts. The Sentinel Hub QGIS plugin allows users to configure and harness Sentinel Hub services directly in QGIS. The Sentinel Hub API is the paid services but the also offer free access for research purpose. More details could found on this link. . Users can also use sentinelsat a python API for searching, downloading and retrieving the metadata of Sentinel satellite images from the Copernicus Open Access Hub. Compared to Sentinel-hub API, this is free services limited to only Copernicus satellites. . Opportunity and Challenges of AI4EO . Machine learning, precisely computer vision, can be applied to EO imagery data for multimodal semantic segmentation, detecting objects, detecting changes from a time series satellite image or image retrieval. The computer vision model can automatically generate semantic maps of a large area from EO data [Audebert2017a]. The resulting semantic maps can be used for the cartography of urban areas or to determine land use cover at a massive scale. In change detection, machine learning models could be used to extend the semantic analysis of EO data by incorporating the multi-temporal dimension. This enables us to track changes around the globe or monitor activity in high-revisit rate acquisitions. It also plays an essential role in the production of maps depicting the evolutions of land use, urban coverage, deforestation, and other multi-temporal type analysis. The image retrieval aims to retrieve images with similar visual contents with respect to the query image from a database. . . Even though AI provides a potential application to EO, several challenges need to be addressed to successfully exploits AI potentials. This is because compared to other types of Data, EO present several challenges for machine learning algorithms. The following video discuss some of the opportunities and challenges of machine learning for EO. . First, the EO data is multimodal and high dimensional. For instance, the EO satellite data come from a variety of sensors types such as passive sensors (RBGN), active sensors (Synthetic Aperture Radar (SAR)), near-infrared sensors. The data also contain additional geo-related data like weather, geo-physical or biochemical quantities and other derived products. This data variety raises the following fundamental challenges when applied to the machine learning model: *how to combine all these data types (data fusion) since all these sources provide complementary information that should be used jointly to maximize the model’s performance. As a result, there is a need to develop novel machine learning models that match EO data taken from different sources with different imaging modalities. Modifying existing vision-based deep networks to these data is not trivial, as this requires to work with new data structures that do not share the same underlying physical and numerical properties. Other exciting topics could be investigating the transferability of deep learning networks to [EO imaging modalities] (https://ieeexplore.ieee.org/document/8113128). Among the other challenges are the sheer number of pixels and the geographic extent per image. For example, a single DigitalGlobe satellite image encompasses &gt; 64 km2 and over 250 million pixels. Also, the objects of interest are microscopic, which complicates traditional computer vision techniques. . The size of EO data is increasing at an exponential rate demanding automation, massive computing, and machine learning algorithms that are fast enough and sufficiently transferrable to be applied for the whole earth’s surface. Besides, these data contain plenty of unlabelled data, making it challenging to use well-established supervised machine learning techniques. Yet this provides an opportunity to explore the recent progress in semi-supervised learning, self-supervised and active-learning methods for EO application. Furthermore, the existence of meta-data and other geo-referenced data such as the Open-street map (OSM) provides an opportunity for creating annotated satellite imagery data for machine learning algorithms. . It should be noted that EO data are time-variable dependent as satellite guarantees continuous data acquisition for decades. For example, the sentinel-1 images the entire earth every six days. Thus machine learning algorithms for EO imagery analysis should jointly exploit both the temporal, spectral, and spatial information of these data. . The interpretability of the machine learning model applicable to EO is another exciting research opportunity. Machine learning models are useful to estimate correlations, but what about causations. Exploiting graphical models and causal discovery to learns cause and effects relations from EO data is a unique opportunity for machine learning in EO. This can be useful for hypothesis testing, model-data comparison, and understanding the causes of extreme impacts. . Conclusion . The satellite has been in the orbit of the earth for many decades, but the access to the data and applications using satellite images has recently become prominent. In this blog, we have introduced the opportunity of using Earth Observation and Artificial Intelligence to address sustainability challenges. We introduced different sources for EO data sources that include public and private satellite providers. We also presented the prominent AI-ready EO data providers and introduced Sentinel-hub, which is an API for accessing EO data from different sources. Finally, the blog highlight opportunity and challenges of applying advanced machine learning techniques such as deep learning for EO imagery data. In the upcoming blog, we will discuss how to download, process, and use EO data for machine learning applications with a specif focus on computational sustainability. Stay tuned for more! . References . Working towards AI and Earth observation | .",
            "url": "https://sambaiga.github.io/sambaiga/machine%20learning/deep%20learning/eearth%20observation/2020/06/20/eo-blog-one.html",
            "relUrl": "/machine%20learning/deep%20learning/eearth%20observation/2020/06/20/eo-blog-one.html",
            "date": " • Jun 20, 2020"
        }
        
    
  
    
        ,"post2": {
            "title": "Energy Based Model Classifier",
            "content": "IDEA: . This post review energy-based model classfier presented in Your Classifier is Secretly an Energy Based Model and You Should Treat it Like One. The paper propose to transform a standard discriminative classifier of $p(y| mathbf{x})$ as an Energy Based Model(EBM) for the joint distribution $p(x, y)$ . An EBM learn to predict if a certain pair of $(x, y)$ fit together or not. Given input variable $ mathbf{x}$ and target variable $ mathbf{y}$. The level of dependency between $x$ and $y$ is defined by the energy function $E_{ theta}(x, y)$ which maps each point to a scalar value. $E_{ theta}(x, y)$ takes low values when $y$ is compatible with $x$ and higher values when $y$ is less compatible with $x$. The energy function $E_{ theta}(x, y)$ can be turned into a normalized joint probability distribution $ p_{ theta}(x, y)$ through the Gibbs distribution: begin{equation} p_{ theta}(x, y) = frac{ exp(- E_{ theta}(x, y)}{Z( theta)} end{equation} . where $Z{ theta} = int_y exp(- E_{ theta}(x, y)$ is is the normalizing constant. . Motivation . Performance gap between the strongest generative modeling approach to downstream tasks (semi-supervised learning, imputation of missing data, and calibration of uncertainty). State-of-the-art generative models have diverged quite heavily from state-of-the-art discriminative architectures. This lead into hand-tailored solutions for each specific problem. . The paper aim at using EBMs to help realize the potential of gen-erative models on downstream discriminative problems. . Approach . The main idea of the paper is to enterpreate the logits of a classifier as the joint density of data points and labels and the density of data points alone. . Consider a machine learning, classifier with K $f_{ theta}( mathbf{x})$ which maps each data point $x in D$ to $K$ real-valued numbers known as logits. The logits parameterize a categorical distribution such as: begin{equation} p_{ theta}(y| mathbf{x})= frac{ exp(f_{ theta}( mathbf{x}))}{ sum exp(f_{ theta}( mathbf{x}))} end{equation} We can re-interpret the logits obtained from $f_{ theta}( mathbf{x})$ to define $p( mathbf{x}, y)$ and $p( mathbf{x})$ as well. Thus the EBM of the joint distribution of data point x and labels y can be defined as: begin{equation} p_{ theta}( mathbf{x}, y)= frac{ exp(f_{ theta}( mathbf{x}))}{Z( theta)} end{equation} where $Z{ theta}$ is unknown normalizing constant and $E{ theta} = -f_{ theta}( mathbf{x}) $ . Marginalizing out y, we obtain an unnormalized density model for x, begin{equation} p_{ theta}( mathbf{x})= sum_y p_{ theta}( mathbf{x}, y) = sum_y frac{ exp(f_{ theta}( mathbf{x}))}{Z( theta)} end{equation} The energy function of a data point x can thus be defined as begin{equation} E_{ theta}(x)= - mathrm{LogSum}_y f_{ theta}( mathbf{x}) = - log sum_y exp(f_{ theta}( mathbf{x})) end{equation} . The conditional distribution $p_{ theta}(y| mathbf{x})$ is can be obitained as begin{equation} p_{ theta}(y| mathbf{x})= frac{p_{ theta}( mathbf{x}, y)}{p_{ theta}( mathbf{x})} end{equation} | . Training EBM . For most choices of $E_{ theta}$, it is hard to compute liably estimate $Z_{ theta}$ which means estimating the normalized densities is intractable and standard maximum likelihood estimation of the parameters $ theta$ is not straightforward. Despite a long period of little development, there has been recent work using this method to train large-scale EBMs on high-dimensional data, parameterized by deep neural networks using Stochastic Gradient Langevin Dynamics (SGLD) . First let consider the derivative of the log-likelihood for a single example $x$ with respect to $ theta$ . begin{equation} frac{ partial log p_{ theta}( mathbf{x})} { partial theta} = mathbb{E}_{p_{ theta}(x^{ prime)})} frac{ partial E_{ theta}( mathbf{x}^{ prime)}} { partial theta} - frac{ partial E_{ theta}( mathbf{x})} { partial theta} end{equation}The SGLD draws samples as follows begin{equation} mathbf{x}_{i+1} = mathbf{x}_i - frac{ alpha}{2} frac{ partial E_{ theta}( mathbf{x})} { partial theta} + epsilon end{equation} where $ mathbf{x}_0 sim p_0( mathbf{x}) $ and $ epsilon sim mathcal{N}(0, alpha)$ . Factorize the likelihood as begin{equation} log p_{ theta}( mathbf{x}, y) = log p_{ theta}( mathbf{x}) + log p_{ theta}(y| mathbf{x}) end{equation} We can therefore optimize $p_{ theta}(y| mathbf{x})$ using standard cross-entropy and optimize $ log p_{ theta}( mathbf{x})$ using Equation 8 with SGLD where gradients are taken with respect to $ mathrm{LogSum}_y f_{ theta}( mathbf{x})$ . Application . Hybrid modeling | Calibration | Out of distribution detection | Robustness | .",
            "url": "https://sambaiga.github.io/sambaiga/machine%20learning/deep%20learning/generative%20models/2020/06/18/ebm-classifier.html",
            "relUrl": "/machine%20learning/deep%20learning/generative%20models/2020/06/18/ebm-classifier.html",
            "date": " • Jun 18, 2020"
        }
        
    
  
    
        ,"post3": {
            "title": "Vectorization and Distribution shapes in Pyro",
            "content": "Introduction . In the previous post we introduced pyro and its building blocks such as schotastic function, primitive sample and param primitive statement, model and guide. We also defined pyro model and use it to generate data, learn from data and predict future observations. . In this section, we will learn in details about inference in Pyro, how to use Pyro primitives and the effect handling library (pyro.poutine) to build custom tools for analysis. . Consider a previous poison regression model . import torch import pyro import pyro.distributions as dist from torch.distributions import constraints import matplotlib.pyplot as plt import seaborn as sns import numpy as np pyro.set_rng_seed(101) torch.manual_seed(101) %matplotlib inline . def model_(y): slope = pyro.sample(&quot;slope&quot;, dist.Normal(0, 0.1)) intercept = pyro.sample(&quot;intercept&quot;, dist.Normal(0, 1)) for t in range(len(y)): rate = torch.exp(intercept + slope * t) y[t] = pyro.sample(&quot;count_{}&quot;.format(t), dist.Poisson(rate), obs=y[t]) . Plate statement . From the given model above , pyro.param designate model parameters that we would like to optimize. Observations are denoted by the obs= keyword argument to pyro.sample. This specifies the likelihood function. Instead of log transforming the data, we use a LogNormal distribution. The observations are conditionally independent given the latent random variable slope and intercept. To explicitly mark this in Pyro, plate statement is used to construct conditionally independent sequences of variables. . with pyro.plate(&quot;name&quot;, size, subsample_size, device) as ind: # ...do conditionally independent stuff with ind... . However compared to range() each invocation of plate requires the user to provide a unique name. The plate statement can be used either sequentially as a generator or in parallel as a context manager. Sequential plate is similar to range()in that it generates a sequence of values. . # This version declares sequential independence and subsamples data: for i in plate(&#39;data&#39;, 100, subsample_size=10): if z[i]: # Control flow in this example prevents vectorization. obs = sample(&#39;obs_{}&#39;.format(i), dist.Normal(loc, scale), obs=data[i]) . Vectorized plate is similar to torch.arange() in that it yields an array of indices by which other tensors can be indexed. However, unlike torch.arange() plate also informs inference algorithms that the variables being indexed are conditionally independent. . # This version declares vectorized independence: with plate(&#39;data&#39;): obs = sample(&#39;obs&#39;, dist.Normal(loc, scale), obs=data) . Additionally, plate can take advantage of the conditional independence assumptions by subsampling the indices and informing inference algorithms to scale various computed values. This is typically used to subsample minibatches of data: . with plate(&quot;data&quot;, len(data), subsample_size=100) as ind: batch = data[ind] assert len(batch) == 100 . You can additionally nest plates, e.g. if you have per-pixel independence: . with pyro.plate(&quot;x_axis&quot;, 320): # within this context, batch dimension -1 is independent with pyro.plate(&quot;y_axis&quot;, 200): # within this context, batch dimensions -2 and -1 are independent . Finaly you can declare multiple plates and use them as reusable context managers. For example if you want to mix and match plates for e.g. noise that depends only on x, some noise that depends only on y, and some noise that depends on both . x_axis = pyro.plate(&quot;x_axis&quot;, 3, dim=-2) y_axis = pyro.plate(&quot;y_axis&quot;, 2, dim=-3) with x_axis: # within this context, batch dimension -2 is independent with y_axis: # within this context, batch dimension -3 is independent with x_axis, y_axis: # within this context, batch dimensions -3 and -2 are independent . def model_(y): slope = pyro.sample(&quot;slope&quot;, dist.Normal(0, 0.1)) intercept = pyro.sample(&quot;intercept&quot;, dist.Normal(0, 1)) with pyro.plate(&#39;N&#39;, len(y)) as t: log_y_hat = slope * t.type(torch.float) + intercept y=pyro.sample(&#39;y&#39;, dist.LogNormal(log_y_hat, 1.), obs=y) . Distribution shapes . Unlike PyTorch Tensors which have a single .shape attribute, pyro Distributions have two shape batch_shape and event_shape. These two combine to define the total shape of a sample. The batch_shape denote conditionally independent random variables, whereas .event_shape denote dependent random variables (ie one draw from a distribution). Because the dependent random variables define probability together, the .log_prob() method only produces a single number for each event of shape .event_shape. . d = dist.Bernoulli(0.5) print(d.batch_shape) print(d.event_shape) . torch.Size([]) torch.Size([]) . x = d.sample() x.shape . torch.Size([]) . Distributions can be batched by passing in batched parameters. . d = dist.Bernoulli(0.5*torch.ones(50)) print(d.batch_shape) print(d.event_shape) . torch.Size([50]) torch.Size([]) . x = d.sample() x.shape . torch.Size([50]) . From the two examples above, we observe that univariate distributions have empty event shape (because each number is an independent event). Let also consider multivariate distribution. . md = dist.MultivariateNormal(torch.zeros(3), torch.eye(3)) print(md.batch_shape) print(md.event_shape) . torch.Size([]) torch.Size([3]) . y = md.sample() y.shape . torch.Size([3]) . We can also create batched multivariate distribution as follows. . md = dist.MultivariateNormal(torch.zeros(3), torch.eye(3)).expand([50]) print(md.batch_shape) print(md.event_shape) . torch.Size([50]) torch.Size([3]) . y = md.sample() y.shape . torch.Size([50, 3]) . Because Multivariate distributions have nonempty .event_shape, the shapes of .sample() and .log_prob(x) differ: . md.log_prob(y).shape . torch.Size([50]) . The Distribution.sample() method also takes a sample_shape parameter that indexes over independent identically distributed (iid) random varables, such that: . sample.shape == sample_shape + batch_shape + event_shape . y_sample =md.sample([10]) y_sample.shape . torch.Size([10, 50, 3]) . Reshaping distributions . You can treat a univariate distribution as multivariate by calling the .to_event(n) property where n is the number of batch dimensions (from the right) to declare as dependent. . d = dist.Bernoulli(0.5*torch.ones(50, 3)).to_event(1) print(d.batch_shape) print(d.event_shape) . torch.Size([50]) torch.Size([3]) . While working with distributions in pyro it is essential to note that: . Samples have shape batch_shape + event_shape, | .log_prob(x) values have shape batch_shape. | You’ll need to ensure that batch_shape is carefully controlled by either trimming it down with .to_event(n) or by declaring dimensions as independent via pyro.plate. | Often in Pyro we’ll declare some dimensions as dependent even though they are in fact independent. This allows us to easily swap in a MultivariateNormal distribution later, but aslo it simplifies the code as we don’t need a plate. Consider the following two codes . x = pyro.sample(&quot;x&quot;, dist.Normal(0, 1).expand([10]).to_event(1)) . x.shape . torch.Size([10]) . with pyro.plate(&quot;y_plate&quot;, 10): y = pyro.sample(&quot;y&quot;, dist.Normal(0, 1)) # .expand([10]) is automatic . y.shape . torch.Size([10]) . From the two code examples, the second version with plate informs Pyro that it can make use of conditional independence information when estimating gradients, whereas in the first version Pyro must assume they are dependent (even though the normals are in fact conditionally independent). .",
            "url": "https://sambaiga.github.io/sambaiga/probabilistic%20programming/pyro/statistical%20inference/machine%20learning/2020/03/04/ppl-pyro-two.html",
            "relUrl": "/probabilistic%20programming/pyro/statistical%20inference/machine%20learning/2020/03/04/ppl-pyro-two.html",
            "date": " • Mar 4, 2020"
        }
        
    
  
    
        ,"post4": {
            "title": "Probabilistic Programming with Pyro",
            "content": "Intro to Pyro . Pyro is a universal probabilistic programming language (PPL) written in Python and supported by PyTorch on the backend. It enables flexible and expressive deep probabilistic modeling, unifying the best of modern deep learning and Bayesian modeling. . Models and Probability distributions . Models are the basic unit of probabilistic programs in pyro, they represent simplified or abstract descriptions of a process by which data are generated. Models in pyro are expressed as stochastic functions which implies that models can be composed, reused, imported, and serialized just like regular Python callables. Probability distributions (pimitive stochastic functions) are important class of models (stochastic functions) used explicitly to compute the probability of the outputs given the inputs. Pyro uses PyTorch’s distribution library which contains parameterizable probability distributions and sampling functions. This allows the construction of stochastic computation graphs and stochastic gradient estimators for optimization. Each probability distributions are equipped with several methods such as: . prob(): $ log p( mathbf{x} mid theta ^{*})$ | mean: $ mathbb{E}_{p( mathbf{x} mid theta ^{*})}[ mathbf{x}]$ | sample: $ mathbf{x}^{*} sim {p( mathbf{x} mid theta ^{*})}$ | . You can also create custom distributions using transforms. . Example 1: Let define the unit normal distribution $ mathcal{N}(0,1)$, draw sample $x$ and compute the log probability according to the distribution. . import torch import pyro import pyro.distributions as dist from torch.distributions import constraints import pandas as pd import numpy as np import matplotlib.pyplot as plt import seaborn as sns pyro.set_rng_seed(101) torch.manual_seed(101) torch.set_printoptions(precision=3) %matplotlib inline . mu = 0 sigma = 1 normal=dist.Normal(mu, sigma) x = normal.rsample() # draw a sample from N(1,1) print(&quot;sample&quot;, x.item()) #To compute the log probability according to the distribution print(&quot;prob&quot;, torch.exp(normal.log_prob(x)).item()) # score the sample from N(1,1) . sample -1.3905061483383179 prob 0.15172401070594788 . Sample and Param statements . Pyro simplifies the process of sampling from distributions with the use of pyro.sample statement. The pyro.sample statement call stochastic functions or models with a unique name as identifier. Pyro’s backend uses these names to uniquely identify sample statements and change their behavior at runtime depending on how the enclosing stochastic function is being used. Using pyro.sample statement, Pyro can implement various manipulations that underlie inference algorithms. . x = pyro.sample(&quot;name&quot;, fn, obs) &quot;&quot;&quot; name – name of sample fn – distribution class or function obs – observed datum (optional; should only be used in context of inference) optionally specified in kwargs &quot;&quot;&quot; . Example 2: Let sample from previous normal distribution created in example 1. . mu = 0 sigma = 1 x = pyro.sample(&quot;my_sample&quot;, dist.Normal(mu, sigma)) print(x) . tensor(-0.815) . The above code generate a random value and records it in the Pyro runtime. . data=2 x = pyro.sample(&quot;my_sample&quot;, dist.Normal(mu, sigma), obs=data) print(x) . 2 . /opt/miniconda3/lib/python3.7/site-packages/pyro/primitives.py:86: RuntimeWarning: trying to observe a value outside of inference at my_sample RuntimeWarning) . The above code conditions a stochatsic function on observed data. This should run on inference. . Pyro use pyro.param statement to saves the variable as a parameter in the param store. To interact with the param store. The pyro.param statement is used by pyro to declares a learnable parameter. . x = pyro.param(&quot;name&quot;, init_value, constraints) &quot;&quot;&quot; name – name of param init_value – initial value constraint – torch constraint &quot;&quot;&quot; . Example 3: Let create theta parameter . theta = pyro.param(&quot;theta&quot;, torch.tensor(1.0), constraint=dist.constraints.positive) . Simple PPL model . Consider the following Poison Regression model begin{align} y(t) &amp; sim lambda exp(- lambda) lambda &amp; sim exp(c + m(t)) c &amp; sim mathcal{N}(1, 1) m &amp; sim mathcal{N}(0, 1) end{align} . def model(y): slope = pyro.sample(&quot;slope&quot;, dist.Normal(0, 0.1)) intercept = pyro.sample(&quot;intercept&quot;, dist.Normal(0, 1)) for t in range(len(y)): rate = torch.exp(intercept + slope * t) y[t] = pyro.sample(&quot;count_{}&quot;.format(t), dist.Poisson(rate), obs=y[t]) return slope, intercept, y . Given a pyro model. We can . Generate data from model | Learn parameters of the model from data | Use the model to predict future observation. | Generate data from model . Running a Pyro model will generate a sample from the prior. . pyro.set_rng_seed(0) # We pass counts = [None, ..., None] to indicate time duration. true_slope, true_intercept, true_counts = model([None] * 50) fig, ax = plt.subplots(figsize=(6,4)) ax = sns.lineplot(x=np.arange(len(true_counts)),y=[c.item() for c in true_counts]) . Learn parameters of the model from data . To learn model parameters we pass the model to an inference algorithm and let the algorithm guess what the model is doing based on observed data. Inference algorithms in Pyro us arbitrary stochastic functions as approximate posterior distributions. that s. These functions are called guide functions or guides and contains pyro.sample and pyro.param statement. It is a stochastic function that represents a probability distribution over the latent (unobserved) variables. The guide can be arbitrary python code just like the model, but with a few requirements: . All unobserved sample statements that appear in the model appear in the guide. | The guide has the same input signature as the model (i.e. takes the same arguments). | There are no pyro.sample statements with the obs keyword in the guide. These are exclusive to the model. | There are pyro.param statements, which are exclusive to the guide. These provide differentiation for the inputs to the pay_probs sample in the guide vs. the model. | For example if the model contains a random variable z_1 . def model(): pyro.sample(&quot;z_1&quot;, ...) . then the guide needs to have a matching sample statement . def guide(): pyro.sample(&quot;z_1&quot;, ...) . Once a guide has been specified, we can then perform learning and inference which is an optimization problem of maximizing the evidence lower bound (ELBO). The ELBO, is a function of both $ theta$ and $ phi$, defined as an expectation w.r.t. to samples from the guide: . $${ rm ELBO} equiv mathbb{E}_{q_{ phi}({ bf z})} left [ log p_{ theta}({ bf x}, { bf z}) - log q_{ phi}({ bf z}) right]$$The SVI class is unified interface for stochastic variational inference in Pyro. To use this class you need to provide: . the model, | the guide, and an | optimizer which is a wrapper a for a PyTorch optimizer as discusseced in below | . from pyro.infer import SVI, Trace_ELBO svi = SVI(model, guide, optimizer, loss=Trace_ELBO()) . The SVI object provides two methods, step() and evaluate_loss(), . The method step() takes a single gradient step and returns an estimate of the loss (i.e. minus the ELBO). | The method evaluate_loss() returns an estimate of the loss without taking a gradient step. | . Both of these methods accept an optional argument: num_particles, which denotes the number of samples used to compute the loss and gradient. . The module pyro.optim provides support for optimization in Pyro. In particular it provides PyroOptim, which is used to wrap PyTorch optimizers and manage optimizers for dynamically generated parameters. PyroOptim takes two arguments: . a constructor for PyTorch optimizers optim_constructor and | a specification of the optimizer arguments optim_args | . from pyro.optim import Adam adam_params = {&quot;lr&quot;: 0.005, &quot;betas&quot;: (0.95, 0.999)} optimizer = Adam(adam_params) . Thus to learn model parameters we pass the model to an inference algorithm and let the algorithm guess what the model is doing based on observed data (here true_counts). . For the above example we will use Autoguide pyro inference algorithm: . AutoLaplaceApproximation:Laplace approximation (quadratic approximation) approximates the posterior log𝑝(𝑧|𝑥) by a multivariate normal distribution in the unconstrained space. | Autodelta: This implementation of AutoGuide uses Delta distributions to construct a MAP guide over the entire latent space. | . from pyro.infer.autoguide import AutoDelta from pyro.infer import SVI, Trace_ELBO from pyro.optim import Adam guide = AutoDelta(model) svi = SVI(model, guide, Adam({&quot;lr&quot;: 0.1}), Trace_ELBO()) for i in range(101): loss = svi.step(true_counts) # true_counts is passed as argument to model() if i % 10 == 0: print(&quot;loss = {}&quot;.format(loss)) . loss = 87295.88946688175 loss = 64525.8595520854 loss = 80838.8460238576 loss = 33014.93229973316 loss = 13704.865498423576 loss = 6232.828522503376 loss = 2017.9879159331322 loss = 631.3558134436607 loss = 170.10323333740234 loss = 198.57187271118164 loss = 207.4590385556221 . print(&quot;true_slope = {}&quot;.format(true_slope)) print(&quot;true_intercept = {}&quot;.format(true_intercept)) guess = guide() print(&quot;guess = {}&quot;.format(guess)) . true_slope = 0.15409961342811584 true_intercept = -0.293428897857666 guess = {&#39;slope&#39;: tensor(0.147, grad_fn=&lt;ExpandBackward&gt;), &#39;intercept&#39;: tensor(-0.054, grad_fn=&lt;ExpandBackward&gt;)} . Use model to predict future observation . A third way to use a Pyro model is to predict new observed data by guiding the model. This uses two of Pyro&#39;s effects: . trace records guesses made by the guide, and | replay conditions the model on those guesses, allowing the model to generate conditional samples. | . Traces are directed graphs whose nodes represent primitive calls or input/output, and whose edges represent conditional dependence relationships between those primitive calls. It return a handler that records the inputs and outputs of primitive calls and their dependencies. . We can record its execution using trace and use the resulting data structure to compute the log-joint probability of all of the sample sites in the execution or extract all parameters. . trace = pyro.poutine.trace(model).get_trace([]) pprint({ name: { &#39;value&#39;: props[&#39;value&#39;], &#39;prob&#39;: props[&#39;fn&#39;].log_prob(props[&#39;value&#39;]).exp() } for (name, props) in trace.nodes.items() if props[&#39;type&#39;] == &#39;sample&#39; }) . {&#39;intercept&#39;: {&#39;prob&#39;: tensor(0.250), &#39;value&#39;: tensor(-0.966)}, &#39;slope&#39;: {&#39;prob&#39;: tensor(2.818), &#39;value&#39;: tensor(0.083)}} . print(trace.log_prob_sum().exp()) . tensor(0.705) . Here, the trace feature will collect values every time they are sampled with sample and store them with the corresponding string name (that’s why we give each sample a name). With a little cleanup, we can print out the value and probability of each random variable’s value, along with the joint probability of the entire trace. . Replay return a callable that runs the original, reusing the values at sites in trace at those sites in the new trace. makes sample statements behave as if they had sampled the values at the corresponding sites in the trace . from pyro import poutine def forecast(forecast_steps=10): counts = true_counts + [None] * forecast_steps # observed data + blanks to fill in guide_trace = poutine.trace(guide).get_trace(counts) _, _, counts = poutine.replay(model, guide_trace)(counts) return counts . We can now call forecast() multiple times to generate samples. . for _ in range(1): full_counts = forecast(10) forecast_counts = full_counts[len(true_counts):] plt.plot([c.item() for c in full_counts], &quot;r&quot;, label=None if _ else &quot;forecast&quot;, alpha=0.3) plt.plot([c.item() for c in true_counts], &quot;k-&quot;, label=&quot;truth&quot;) plt.legend(); . References . Pyro-ducomentation | PPL models for timeseries forecasting |",
            "url": "https://sambaiga.github.io/sambaiga/probabilistic%20programming/pyro/statistical%20inference/machine%20learning/2020/03/01/ppl-pyro-intro.html",
            "relUrl": "/probabilistic%20programming/pyro/statistical%20inference/machine%20learning/2020/03/01/ppl-pyro-intro.html",
            "date": " • Mar 1, 2020"
        }
        
    
  
    
        ,"post5": {
            "title": "Stochastic Variational Inference (SVI)",
            "content": "The previous post introduced the basic principle of Variational Inference (VI) as one of the approach used to approximate difficult probability distribution, derived the ELBO function and discussed about Mean Field Variational Inference (MFVI) and the Coordinate Ascent Variational Inference (CAVI) algorithms. This post introduce another stochastic gradient based algorithm (SVI) used in practise to do VI under mean filed assumptions. It also present two important tricks re-parametrization trick and amortized inference that are useful when using SVI in solving problems. . Stochastic Variational Inference (SVI) . Consider the graphical model of the observations $ mathbf{x}$ and latent variable $ mathbf{z}= { theta, z }$ in figure 1 where $ theta$ is the global variable and $z = {z_1, ldots z_n }$ is the local (per-data-point) variable such that: . . $$ p( mathbf{x}, mathbf{z}) = p( theta| alpha) prod_{i=1}^N p(x_i|z_i, theta) cdot p(z_i| alpha) $$ . Similarly the variational parameters are given by $ lambda = { gamma, phi } $ where the variational parameter $ gamma$ correspond to latent variable and $ phi$ denote set of local variational parameters. The variational distribution $q( mathbf{z} mid phi)$ is given by . $$ q( mathbf{z} mid phi) = q( theta| gamma) prod_{i=1}^N q(z_i| phi_i, alpha) $$which also depend on hyper-parameter $ alpha$. The ELBO of this graphical model $ mathcal{L}_{VI}(q) = mathbb{E}_q[ log p( mathbf{x}, mathbf{z}, alpha) - log q( mathbf{z}, gamma)]$ has the following form: . $$ begin{split} mathcal{L}_{VI}(q) &amp;= mathbb{E}_q[ log p( theta| alpha)- log q( theta| gamma)] &amp;+ sum_{i=1}^{N} mathbb{E}_q[ log p(z_i| theta) + log p(x_i|z_i, theta)- log q(z_i| phi_i)] end{split} $$ The equation above could be optimized by CAVI algorithm discussed in previous post which is expensive for large data sets. The CAVI algorithm scales with $N$ as it require to optimize the local variational parameters for each data point before re-estimating the global variational parameters. . Unlike CAI, SVI uses stochastic optimization to fit the global variational parameters by repeatedly sub-sample the data to form stochastic estimate of ELBO. In every iteration one randomly selects mini-batches of size $b_{sz}$ to obtain a stochastic estimate of ELBO. . $$ begin{split} mathcal{L}_{VI}(q) &amp;= mathbb{E}_q[ log p( theta| alpha)- log q( theta| gamma)] &amp;+ frac{N}{b_{sz}} sum_{s=1}^{b_{sz}} mathbb{E}_q[ log p(z_{i_s}| theta) + log p(x_{i_s}|z_{i_s}, theta)- log q(z_{i_s}| phi_{i_s})] end{split} $$SVI algorithms follow noisy estimates of the gradient with a decreasing step size which is often cheaper to compute than the true gradient. Following such noisy estimates allows SVI to escape shallow local optima of complex objective functions. . Natural Gradient for SVI . To solve the optimization problem standard gradient-based methods such as SGD, Adam or Adagrad can be used. However, for SVI these gradient based methods cause slow convergence or converge to inferior local models. This is because, gradient based methods use the following update . $$ theta^{t+1}= theta^t + alpha frac{ partial mathcal{L}_{VI}(q)}{ partial theta} $$where . $$ frac{ partial mathcal{L}_{VI}(q)}{ partial theta} = frac{ partial mathcal{L}_{VI}(q)}{ partial theta_1}, ldots frac{ partial mathcal{L}_{VI}(q)}{ partial theta_k} $$ . is the the gradient vector which point in the direction where the function increases most quickly while the changes in the function are measured with respect to euclidean distance. As the result, if the euclidean distance between the variational parameter being optimized is not good measure of variation in objective function then gradient descent will move suboptimal through the parameter value. . Consider the following two set of gausian distributions $$ {d_{(1)}= mathcal{N}(-2, 3), d_{(2)}= mathcal{N}(2, 3) }$$ and $$ {d_{(1)}= mathcal{N}(-2, 1), d_{(2)}= mathcal{N}(2, 1) }$$. . The euclidean distance between the two distributions $d_{}= sqrt{( mu_1- mu_2)^2+ ( sigma^2_1- sigma^2_2)^2}=4$ It clear that, considering only the euclidean distance the two images are the same. However, when we consider the shape of the distribution, the distance is different in the first and second image. In the first image, the KL-divergence should be lower as there is more overlap between between the two distribution unlike the second image where their support barely overlap. The reason for this difference is that probability distribution do not naturally fit in euclidean space rather it fit on a statistical manifold also called Riemannian manifold. . Statistical manifold give a natural way of measuring distances between distribution that euclidean distance use in SGD. A common Riemannian metric for statistical manifold is the fisher information matrix defined by . $$ F_{ lambda} = mathbb{E}_{p(x; lambda)}[ nabla log p(x; lambda) ( nabla log p(x; theta))^T ] $$ It can be showed that the fisher information matrix $F_{ lambda}$ is the second derivative of the KL divergence between two distributions. . $$ F_{ theta} = nabla^2_{ theta} KL(q(x; lambda)||p(x; theta)) $$Thus for SVI, the standard gradients descent techniques can be replaced with the natural gradient as follows: . $$ tilde{ nabla_{q}} mathcal{L}(q) = F^{-1} nabla{q} mathcal{L}_{VI}(q) $$The update procedure for natural gradient can be summarized as follows: . Compute the loss $ mathcal{L}_{VI}(q)$ | Compute the gradient of the loss $ nabla{q} mathcal{L}_{VI}(q)$ | Compute the Fisher Information Matrix F. | Compute the natural gradient $ tilde{ nabla_{q}} mathcal{L}_{VI}(q)$ | Update the parameter $q^{t+1} =q^t - alpha tilde{ nabla_{ theta}} mathcal{L}_{VI}(q)$ | Using natural gradient instead of standard gradients simplify SVI gradient update. However the same conditions for convergence as standard SDG have to be fulfilled. First, the mini-batch indices must be drawn uniformly at random size where the size $b_{sz}$ of the mini-batch must satisfies $1 leq b_{sz} leq N$ The learning rate $ alpha$ needs to decrease with iterations $t$ satisying the Robbins Monro conditions $ sum_{t=1}^{ infty} alpha_t = infty$ and $ sum_{t=1}^{ infty} alpha_t^2 &lt; infty$ This guarantee that every point in the parameter space can be reached while the gradient noise decreases quickly enough to ensure convergence. . The next section presents two important tricks namely re-parametrization trick and amortized inference that are useful when using SVI in solving problems. . Re-parametrization trick . Consider the graphical model presented in figure 1, where gradient based stochastic optimization is used to learn the variational parameter $ phi$. For example; for Gaussian distribution $q_{ phi}(z|x)= mathcal{N}( mu_{ phi}(x), Sigma_{ phi}(x))$ . To maximize the likelihood of the data, we need to back propagate the loss to the parameter $ phi$ across the distribution of $z$ or across sample $z sim q_ phi(z mid x) $ However, it is difficulty to back-propagate through random variable. To address this problem, the re-parametrization trick is used. . First let consider the Law of the Unconscious Statistician (LOTUS), that is used to calculate the expected value of a function $g( epsilon)$ of a random variable $ epsilon$ when only the probability distribution $p( epsilon)$ of $ epsilon$ is known. The Law state that: . To compute the expectation of a measurable function $g(.)$ of a random variable $ epsilon$, we have to integrate $g( epsilon)$ with respect to the distribution function of $ epsilon$, that is:$$ mathbb{E}(g( epsilon)) = int g( epsilon)dF_{ epsilon}( epsilon) $$ . In other words, to compute the expectation of $z =g( epsilon)$ we only need to know $g(.)$ and the distribution of $ epsilon$. We do not need to explicitly know the distribution of $z$. Thus the above equation can be expression in the convenient alternative notation: . $$ mathbb{E}_{ epsilon sim p( epsilon)}(g( epsilon)) = mathbb{E}_{z sim p(z)} (z) $$Therefore the reparameteriztaion trick states that: . A random variable $z$ with distribution $q_{ phi}(z, phi)$ which is independent to $ phi$ can be expressed as transformation of random variable $ epsilon sim p( epsilon)$ that come from noise distribution such as uniform or gaussian such that $z = g( phi, epsilon)$ . For instance for Gaussian variable $z$ in the above example . $$ z = mu( phi) + sigma^2( phi) cdot epsilon $$where $ epsilon sim mathcal{N}(0, 1)$. Since $p( epsilon)$ is independent of the parameter of $q_{ phi}(z, phi)$, we can apply the change of variables in integral theory to compute any expectation over $z$ or any expectation over $ phi$. The SDG estimator can therefore be estimated by pulling the gradient into expectations and approximating it by samples from the noise distribution such that for any measurable function $f_{ theta}(.)$:$$ Delta_{ phi} mathbb{E}_{z sim p_{ phi}(z)} = frac{1}{M} sum_{i=1}^M Delta f(g( phi, epsilon_i)) $$ . where $ epsilon_i sim p( epsilon)$ , $f_{ theta}(.)$ must be differentiable w.r.t its input $z$ and $g( phi, epsilon_i)$ must exist and be differentiable with respect to $ phi$. . Amortized Variational Inference . Consider the graphical model presented in figure 1 where ecah data point $x_i$ is governed by its latent variable $z_i$ with variational parameter $phi_i$ such that . $$ q( mathbf{z} mid phi) = q( theta| gamma) prod_{i=1}^N q(z_i| phi_i, alpha) $$Using traditional SVI make it necessary to optimize $ phi_i$ for each data point $x_i$. As the results the number parameters to be optimized will grows with the number of observations $x$. This is not ideal for larger datasets. Apart from that, it requires one to re-run the optimization procedure in case of new observation or when we have to perform inference. To address these problem amortized VI introduce a parametrized function that maps from observation space to the parameter of the approximate posterior distribution. . Amortized VI try to learn from past inference/pre-computation so that future inferences run faster. Instead of approximating separate variables for each data point $x_i$, amortized VI assume that the local variational parameter $ phi$ can be predicted by a parametrized function $f_{ phi}(.)$ of data whose parameters are shared across all data points. Thus instead of introducing local variational parameter, we learn a single parametric function and work with a variational distribution that has the form . $$ q( mathbf{z} mid phi) = q( theta| gamma) prod_{i=1}^N q(z_i|f_{ phi}(.)) $$where $f_{ phi}(.)$ is the deep neural net function of $z$ . Deep neural network used in this context are called inference networks. Therefore amortized inference with inference networks combines probabilistic modelling with representation power of deep learning. Using amortized VI instead of traditional VI, has two important advantages. First the number of variational parameters remain constant with respect to the data size. We only need to specify the parameter of the neural networks which is independent to the number of observations. Second, for new observation or during inference all we need to do is to call the inference network. As the result, we can invest time upfront optimizing the inference network and during inference we use the trained network for fast inference. . Consider a binary regression problem where we are intrested on predicting whether or not a customer will subscribe a term deposit after the marketing campaign the bank performed. . ## Reference 1. [[Cheng Zhang,(2017)]](https://arxiv.org/abs/1711.05597): Advances in Variational Inference. 2. [[Daniel Ritchie,(2016)]](https://arxiv.org/abs/1610.05735):Deep Amortized Inference for Probabilistic Programs. 3. [[Andrew Miller,(2016)]](https://arxiv.org/abs/1610.05735):Natural Gradients and Stochastic Variational Inference. 4. [Shakir Mohamed](https://www.shakirm.com/papers/VITutorial.pdf):Variational Inference for Machine Learning. 5. [DS3 workshop](https://emtiyaz.github.io/teaching/ds3_2018/ds3.html):Approximate Bayesian Inference: Old and New. 6. [Variational Inference and Deep Generative Models](https://github.com/philschulz/VITutorial):Variational Inference for NLP audiences .",
            "url": "https://sambaiga.github.io/sambaiga/deep%20learning/machine%20learning/generative%20model/2019/05/02/svi.html",
            "relUrl": "/deep%20learning/machine%20learning/generative%20model/2019/05/02/svi.html",
            "date": " • May 2, 2019"
        }
        
    
  
    
        ,"post6": {
            "title": "Basics of Python for Data Science and Machine learning",
            "content": "images/post/python.jpg . Basics . Python is a very popular general-purpose programming language. . Open source general-purpose language | Dynamically semantics (rather than statically typed like Java or C/C++) | Interpreted (rather than compiled like Java or C/C++) | Object Oriented. | . Why is Python such an effective tool in scientific research ? . Interoperability with Other Languages : You can use it in the shell on microtasks, or interactively, or in scripts, or build enterprise software with GUIs. | “Batteries Included” + Third-Party Modules : Python has built-in libraries and third-party liabraies for nearly everything. | Simplicity &amp; Dynamic Nature : You can run your Python code on any architecture. | Open ethos well-fit to science : Easy to reproduce results with python | . Why is Python such an effective tool for Data Science and Machine learning research . Very rich scientific computing libraries (numpy, matplotlib, pandas, scipy etc) and machine learning frameworks (Pytorch, Tensorflow, keras, mxnet, etc) | All DS and ML tasks can be performed with Python : accessing, collecting, cleaning, analysing, visualising data modelling, evaluating models, integrating in prod, scaling etc. | . | . Python 2 VS. Python 3 . Two major versions of Python in widespread use : Python 2.x and Python 3.x . Some features in Python 3 are not backward compatible with Python 2 | Some Python 2 libraries have not been updated to work with Python 3 | Bottom-line : there is no wrong choice, as long as all the libraries you need are supported by the version you choose but most of libararies are phasing out python 2.x. | In this training : Python3 | . Python vs other language . print(&quot;Hello World&quot;) . Consider hello world in Java and C++ . Java . public class HelloWorld { public static void main(String[] args) { // Prints &quot;Hello, World&quot; to the terminal window. System.out.println(&quot;Hello, World&quot;); } } . C++ . #include &lt;iostream&gt; using namespace std; int main() { cout &lt;&lt; &quot;Hello, World!&quot;; return 0; } . 1.1 Comments . Text to the right of the // symbol are comments used as notes for the reader of the program. . print(&quot;Hello world&quot;) # This is hello world . Use as many useful comments as you can in your program to: . explain assumptions | explain important decisions | explain important details | explain problems you&#39;re trying to solve | explain problems you&#39;re trying to overcome in your program, etc | . Code tells you how, comments should tell you why. . 1.2 Variable and Print Statement . Variable: A name that is used to denote something or a value is called a variable. In python, variables can be declared and values can be assigned to it. . We use a single equals sign to assign labels to variables. Let&#39;s see a few examples of how we can do thi . # Variables and assignment a = 3 print (a) . s = &quot;parrotai&quot; print(s) . c= 10 + 5j print(c) . To know the type of variable use type() function . type(a) . type(c) . type(s) . Choosing a variable name: . The names you use when creating these labels need to follow a few rules: . Names can not start with a number. | There can be no spaces in the name, use _ instead. | Can&#39;t use any of these symbols :&#39;&quot;,&lt;&gt;/?|()!@#$%^&amp;*~-+ | It&#39;s considered best practice (PEP8) that the names are lowercase. | Print Statements . The print statement can be used in the following different ways : . - print(variable_name) - print(&quot;Hello World&quot;) - print (&quot;Hello&quot;, &lt;Variable &gt;) - print (&quot;Hello&quot; + &lt;Variable Containing the String&gt;) - print (&quot;Hello %s&quot; % &lt;variable containing the string&gt;) - print (&quot;Hello&quot; + &lt;Variable Containing the String&gt;) - print (&quot;Hello %d&quot; % &lt;variable containing integer datatype&gt;) - print (&quot;Hello %f&quot; % &lt;variable containing float datatype&gt;) . acc = 89 fs = 60.20 model = &quot;Random Forest&quot; print(&quot;The perfomance results for %s model: Accuracy: %d ; F-score: %.3f&quot; %(model,acc,fs)) . Alternatively you can use .format() in print function . print(&quot;The perfomance results for {0} model: Accuracy: {1} ; F-score: {2}&quot; .format(model,acc,fs)) . print(f&quot;The perfomance results for {model} model: Accuracy: {acc} ; F-score: {fs}&quot;) . Activity 1: Write a program that prints your full name and your birthdate as separate strings. # DO IT HERE . User Input . input( ) accepts input and stores it as a string. Hence, if the user inputs a integer, the code should convert the string to an integer and then proceed... . a = input(&quot;Type something here and it will be stored in this variable t&quot;) . a . type(a) . You can convert the enterd number to int, using int() function to float with foat() function as follows: . a = int(input(&quot;Only integer can be stored in this variable t&quot;)) b = float(input(&quot;Only float can be stored in this variable t&quot;)) . print(a) . print(b) . 1.3 Operators and Expressions . Numeric operator . + (plus) : 2 + 1 =3 | - (minus): : 2 - 1 =1 | * (multiply): 2*1 =2 | ** (power): 3**2 =9 | / (divide): 3/2 =1.5 | // (divide and floor): 3//2 =1 | % (modulo)&quot; 5%3=2 | . x = 5 y = 6.0 . print(x+y) . print(x*y) . print(x**y) . print(20%6) . Logical operators . == (equal to)) : Compares if the objects are equal | != (not equal to): : Compares if the objects are not equal | not : (boolean NOT) | and (boolean AND) | or (boolean OR) | &gt; (greater than): Returns whether x is greater than y | &lt; (less than): Returns whether x is less than y. | &lt;= (less than or equal to) | &gt;= (greater than or equal to) | . Activity 2: Suppose you have $20,000$ tsh, which you can invest with a $10$ % return each year. Write python code to calculate how much money you end up with after $5$ years. 1.4 Control Flow . Indentation . It is important to keep a good understanding of how indentation works in Python to maintain the structure and order of your code. We will touch on this topic again when we start building out functions! . IF statement . The if statement is used to check a condition: if the condition is true, we run a block of statements (called the if-block), else we process another block of statements (called the else-block). The else clause is optional. . if . if some_condition: algorithm . If-else . if some_condition: algorithm else: algorithm . if-elif (nested if) . if some_condition: algorithm elif some_condition: algorithm else: algorithm . # Example avoid division by zero val = 0 num = 10 if val == 0: val += 2e-07 result = num / val print(&quot;{0} dived {1:.2f} = {2:.2f}&quot;.format(num, val, result)) . # Example avoid division by zero user_name = &quot;sambaiga&quot; password = &quot;sa1254&quot; if user_name==&quot;sambaiga&quot;: print(&quot;Hello &quot;,user_name) if password !=&quot;sa1234&quot;: print(&quot;Wrong password&quot;) else: print(&quot;Access granted&quot;) else: print(&quot;user does not exist&quot;) . # Unlike other languages, indentation is significant a = 5 if a &gt; 10: print (&#39;a is greater than 10&#39;) if a &gt;= 15: print (&#39;a is also at least 15&#39;) elif a &gt; 5: print (&#39;a is greater than 5 but not greater than 10&#39;) else: print (&#39;no condition matched&#39;) print (&#39;so a is 5 or less&#39;) . While statement . The while statement allows you to repeatedly execute a block of statements as long as a condition is true. . while some_condition: algorithm . # Example i = 1 while i &lt; 5: print(&quot;The square root of {0} is {1}&quot;.format(i, i**2)) i = i+1 . For Loops . A for loop acts as an iterator in Python, it goes through items that are in a sequence or any other iterable item. We will see more about sequences in detail in later section. . for variable in something: algorithm . for i in range(6): print(i) . Note range( ) function outputs the integers of the specified range. It can also be used to generate a series by specifying the difference between the two numbers within a particular range. The elements are returned in a list. . Example: . Another common idea during a for loop is keeping some sort of running tally during the multiple loops. For example, lets create a for loop that sums up the list of number from 0 to 9: . num_sum = 0 for num in range(10): num_sum +=num print(num_sum) . Activity 3: Compute $$ sum_{k=1}^N frac{1}{2^k}$$ for N = 10, N = 20 and N = 100. What happens when n gets larger and larger? The break and continue Statement . The break statement is used to break out of a loop statement i.e. stop the execution of a looping statement, even if the loop condition has not become False or the sequence of items has not been completely iterated over. . | The continue statement is used to tell Python to skip the rest of the statements in the current loop block and to continue to the next iteration of the loop. . | . while True: s = int(input(&#39;Enter something : &#39;)) if s == 0: break if s%2 == 0: print(&#39;The number is even&#39;) continue #print(&#39;Input is of sufficient length&#39;) # Do other kinds of processing here... . Progress bar . Make your loops show a smart progress meter . import tqdm from tqdm import tqdm as pbar . sum_of_n = 0 N = 1e10 for i in pbar(range(10000000)): sum_of_n+=i print(sum_of_n) . 1.5 Data Structures: . Are structures which can hold some data together, used to store a collection of related data. . 1.5.1 Sequences . Sequence Types:There are three basic sequence types: lists, tuples, and range objects. . Lists . create list | add item to list | access elements of a list | . #name, gender, height, age, weight, region, status data = [&quot;James John&quot;, &quot;M&quot;, 176, 28, &quot;Dodoma&quot;, 1] print(data) . data[0] . data[0:2] . #what about #data[-1] . data.append(&quot;350K&quot;) data . # access all elements in a list for item in data: print(item) . List comprehensions . # create list of square of number from 1 to 10 [x**2 for x in range(1, 11)] . ### alternatively square = [] for x in range(1, 11): square.append(x**2) square . ## size of a list len(square) . More list methods . Activity 4: Build a list that contains every prime number between 1 and 100, in two different ways: 1. Using for loops and conditional if statements. 2. Using a list comprehension. ## CODE HERE . Tuples . A tuple consists of a number of values separated by commas, for instance: . t = 2, 5, &#39;parrot&#39; t . (2, 5, &#39;parrot&#39;) . As you see, on output tuples are always enclosed in parentheses . Though tuples may seem similar to lists, they are often used in different situations and for different purposes. . Tuples are immutable, and usually contain a heterogeneous sequence of elements are accessed via unpacking. | Lists are mutable, and their elements are usually homogeneous and are accessed by iterating over the list. | . The statement t = 2, 5, &#39;parrot&#39; is an example of tuple packing: the values 2, 5, &#39;parrot are packed together in a tuple. The reverse operation is also possible: . x, y,z = t . Range . The range type represents an immutable sequence of numbers and is commonly used for looping a specific number of times in for loops. . syntax: range(start, stop, step) . start: The value of the start parameter (or 0 if the parameter was not supplied) | stop: The value of the stop parameter | step: The value of the step parameter (or 1 if the parameter was not supplied) | . list(range(10)) . list(range(0, 30, 5)) . Common Sequence Operations . The following operations are supported by most sequence types, both mutable and immutable. . x in s: True if an item of s is equal to x, else False | x not in s: False if an item of s is equal to x, else True | s + t :the concatenation of s and t | s * n or n * s: equivalent to adding s to itself n times | len(s): length of s | min(s): smallest item of s | max(s): largest item of s | s.count(x): total number of occurrences of x in s | . Important python function . To loop over two or more sequences at the same time, the entries can be paired with the zip() function. | When looping through a sequence, the position index and corresponding value can be retrieved at the same time using the enumerate() function. | . days = [&#39;Mon&#39;, &#39;Tue&#39;, &#39;Wed&#39;, &#39;Thus&#39;, &#39;Fr&#39;, &quot;Sat&quot;, &#39;Sun&#39;] months = [&#39;Jan&#39;, &#39;Feb&#39;, &#39;March&#39;, &#39;Apr&#39;, &#39;May&#39;, &quot;Jun&quot;, &#39;July&#39;] . ## enumerate: for i, day in enumerate(days): print(f&#39;index {i}, {day}&#39;) . ## enumerate: for day, month in zip(days, months): print(f&#39;{day}, {month}&#39;) . 1.5.2 Dictionary . We&#39;ve been learning about sequences in Python but now we&#39;re going to switch gears and learn about mappings in Python. If you&#39;re familiar with other languages you can think of these Dictionaries as hash tables. Dictionaries are more used like a database because here you can index a particular sequence with your user defined string. . Mappings are a collection of objects that are stored by a key, unlike a sequence that stored objects by their relative position. This is an important distinction, since mappings won&#39;t retain order since they have objects defined by a key. A Python dictionary consists of a key and then an associated value. That value can be almost any Python object. . We create a dictionary with {} and : to signify a key and a value . my_dict = {&#39;key1&#39;:&#39;value1&#39;,&#39;key2&#39;:&#39;value2&#39;} . # create dictionary dic = { &#39;name&#39;:&quot;James John&quot;, &#39;age&#39;: 28, &#39;gender&#39;:&quot;M&quot;, &#39;region&#39;:&quot;Dodoma&quot;, &#39;status&#39;:1 } print(dic) . {&#39;name&#39;: &#39;James John&#39;, &#39;age&#39;: 28, &#39;gender&#39;: &#39;M&#39;, &#39;region&#39;: &#39;Dodoma&#39;, &#39;status&#39;: 1} . In addition, dict comprehensions can be used to create dictionaries from arbitrary key and value expressions: . square={x: x**2 for x in range(1,11)} square . # Access value of element by key - most important feature! print(dic[&#39;age&#39;]) . 28 . dic[&#39;salary&#39;] = &quot;310K&quot; print(dic) . #get list keys of a dictionary dic.keys() . dict_keys([&#39;name&#39;, &#39;age&#39;, &#39;gender&#39;, &#39;region&#39;, &#39;status&#39;]) . #get list values in a dictionary dic.values() . dict_values([&#39;James John&#39;, 28, &#39;M&#39;, &#39;Dodoma&#39;, 1]) . #get list key, values pairs item in a dictionary for key , value in dic.items(): print(&quot;{0}: {1}&quot;.format(key, value)) . 1.6 Functions . Functions will be one of our main building blocks when we construct larger amounts of code to solve problems. . function is a useful device that groups together a set of statements so they can be run more than once. They can also let us specify parameters that can serve as inputs to the functions. . | functions allow us to not have to repeatedly write the same code again and again. . | function in Python is defined by a def statement. The general syntax looks like this: | . def name_of_function(arg1,arg2): &#39;&#39;&#39; This is where the function&#39;s Document String (doc-string) goes &#39;&#39;&#39; # Do stuff here #return desired result . Note: Docstrings: . Documentation about what the function does and its parameters. General convention: . def normalize(data=None, mean=None, std=None): &#39;&#39;&#39; Normalization function arguments: data: the data value you want to normalize mean: mean value of your data std: standard deviation of your data return: z-score: normalized value &#39;&#39;&#39; return (data - mean)/ std . result = normalize(data=27.8, mean=18, std=6) print(&quot;Normalized value is {:.2f}&quot;.format(result)) . Activity 5:Write a function called accept login(users, username, password) with three parameters: users a dictionary of username keys and password values, username a string for a login name and password a string for a password. The function should return True if the user exists and the password is correct and False otherwise. Here is the calling code, test your code with both good and bad passwords as well as non-existent login names: ## CODE HERE . Activity 6: The distance between two points x and y is the square root of the sum of squared differences along each dimension of x and y. Create a function distance(x, y) that takes two vectors and outputs the distance between them. Use your function to find the distance between (0,0) and (1,1). ## CODE HERE . Activity 7: Using distance() function created in activity 6. Make a function in_circle(x, origin) that uses distance to determine if a two-dimensional point falls within the the unit circle with a given origin. That is, find if a two-dimensional point has distance $&lt;1$ from the origin (0,0).Use your function to print whether the point (1,1) lies within the unit circle centered at (0,0). ## CODE HERE . Lambda Expressions . Small anonymous functions can be created with the lambda keyword. In Python, anonymous function means that a function is without a name. . syntax: lambda arguments: expression . sq = lambda x: x**2 . sq(2) . Lambda functions can be used along with built-in functions like . filter(): Construct an iterator from those elements of iterable for which function returns true, | map(): Return an iterator that applies function to every item of iterable, yielding the results and | . Example: . Given list of ages for participants of AISG bootcamp = [10, 12, 22, 80, 50, 16, 33, 18, 17, 29] . Let us filter out teenagers from this list . age = [10, 12, 22, 80, 50, 16, 33, 18, 17, 29] lf=lambda x: (x&lt;=18 and x&gt;=12) teenagers=list(filter(lf , age)) print(teenagers) . Let use standarzide the list of age . import statistics as st mu=st.mean(age) std=st.stdev(age) lf = lambda x: round((x - mu)/std, 2) standarzied_age = list(map(lf ,age)) print(standarzied_age) . 1.7 Module . Modules are organized units (written as files) which contain functions, statements and other definitions. . Any file ending in .py is treated as a module (e.g., my_function.py, which names and defines a function my_function) . | Modules: own global names/functions so you can name things whatever you want there and not conflict with the names in other modules. . | . %%writefile normalizer.py def normal(data=None, mean=None, std=None): &#39;&#39;&#39; Normalization function arguments: data: the data value you want to normalize mean: mean value of your data std: standard deviation of your data return: z-score: normalized value &#39;&#39;&#39; return (data - mean)/ std . Packages . Packages are name-spaces which contain multiple packages and modules themselves. They are simply directories, but with a twist. | Each package in Python is a directory which MUST contain a special file called __init__.py. This file can be empty, and it indicates that the directory it contains is a Python package, so it can be imported the same way a module can be imported. | . To Import modules and packages . Different options are available: . import package-name importing all functionalities as such&lt;/li&gt; from package-name import specific function importing a specific function or subset of the package/module&lt;/li&gt; from package-name import * importing all definitions and actions of the package (sometimes better than option 1)&lt;/li&gt; import package-name as short-package-name Very good way to keep a good insight in where you use what package&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; import normalizer result = normalizer.normal(data=27.8, mean=18, std=6) print(&quot;Normalized value is {:.2f}&quot;.format(result)) . #Alternatively from normalizer import normal result = normal(data=27.8, mean=18, std=6) print(&quot;Normalized value is {:.2f}&quot;.format(result)) . Import modules from another directory . import sys sys.path.append(&#39;src/&#39;) import normalizer as norm result = norm.normal(data=27.8, mean=18, std=6) print(&quot;Normalized value is {:.2f}&quot;.format(result)) . Important python module . statistics — Mathematical statistics functions: This module provides functions for calculating mathematical statistics of numeric (Real-valued) data | math — Mathematical functions: This module provides access to the mathematical functions defined by the C standard. | random— Generate pseudo-random numbers:This module implements pseudo-random number generators for various distributions. | . import math . Activity 8: Using the math library, calculate and print the value of pi / 4. ## CODE HERE . import random ## Random Shuffle data in a list random.shuffle(age) print(age) . ## Random select element from a list random.choice(age) . # Return a k length list of unique elements chosen from the population sequence or set. Used for random sampling without replacement. random.sample(age, 5) . Activity 9: Using random.uniform, create a function rand(n) that generates a single float between -n and n. Call rand() once. So we can check your solution, we will use random.seed to fix the value called by your function. Note: add random.seed(1) to fixes the value called by your function, def rand(n=1): random.seed(1) #code here . Activity 10: Use the rand function defined from previous exercise to create a list x with 10000 number between -1 and 1 ## CODE HERE . Activity 11: Use the in_circle are defined from previous exercise. Create a list of 10000 booleans called inside that are True if and only if the point in x with that index falls within the unit circle. Make sure to use in_circle. Print the proportion of points within the circle. This proportion is an estimate of the ratio of the two areas! 1.7 Reading and Writing Data to Files in Python . To read and write file in python you must first open files in the appropriate mode and read its contents: . with open(&#39;data/sms.txt&#39;, &#39;r&#39;) as f: sms = f.read() f.close() . open() takes a filename and a mode as its arguments. | r opens the file in read only mode. To write data to a file, pass in w as an argument instead: | . sms . with open(&#39;data/data.txt&#39;, &#39;w&#39;) as f: data = &#39;some data to be written to the file&#39; f.write(data) f.close() . data . Reading text files line-by-line and save to list . sms_list = [] with open(&#39;data/sms.txt&#39;, &#39;r&#39;) as f: for line in f: l=line.strip() #removes any leading (spaces at the beginning) and trailing (spaces at the end) characters if len(l)!=0: # The EOF char is an empty string sms_list+=[float(l)] f.close() . sms_list . st.mean(sms_list) . st.variance(sms_list) . st.stdev(sms_list) . Directory Listing . os.listdir() is the method to use to get a directory listing: . import os dirs = os.listdir(&#39;data/&#39;) dirs . os.listdir() returns a Python list containing the names of the files and subdirectories in the directory given by the path argument. . for file in dirs: print(file) . In modern versions of Python, an alternative to os.listdir() is to use os.scandir() and pathlib.Path(). . with os.scandir(&#39;data/&#39;) as dirs: for file in dirs: print(file.name) . from pathlib import Path dirs = Path(&#39;data/&#39;) for file in dirs.iterdir(): print(file.name) . Making Directories . ##check if path exist os.path.isdir(&quot;data/&quot;) . if os.path.isdir(&quot;results/&quot;): os.mkdir(&#39;results/&#39;) . Exercise 1 : . A list of numbers can be very unsmooth, meaning very high numbers can be right next to very low numbers. This list may represent a smooth path in reality that is masked with random noise.One way to smooth the values in the list is to replace each value with the average of each value&#39;s neighbors, including the value itself. . Write a function moving_window_average(x, n_neighbors) that takes a list x and the number of neighbors n_neighbors on either side to consider. For each value, the function computes the average of each value&#39;s neighbors, including themselves. Have the function return a list of these averaged values that is the same length as the original list. If there are not enough neighbors (for cases near the edge), substitute the original value as many times as there are missing neighbors. Use your function to find the moving window sum of sms list and n_neighbors=2. | Compute the moving window average for sms_list for the range of n_neighbors 1-9. Store sms_list as well as each of these averages as consecutive lists in a list called sms_mva. | For each list in sms_mva, calculate and store the range (the maximum minus the minimum) in two decimal places in a new list ranges. Print your answer. As the window width increases, does the range of each list increase or decrease? Why do you think that is? | #solution 1 def moving_window_average(x, n_neighbors=1): n = len(x) width = n_neighbors*2 + 1 x = [x[0]]*n_neighbors + x + [x[-1]]*n_neighbors # To complete the function, # return a list of the mean of values from i to i+width for all values i from 0 to n-1. return [sum(x[i:(i+width)]) / width for i in range(n)] mv=moving_window_average(sms_list, 2) . #sloution 2 Y = [sms_list] + [moving_window_average(sms_list, n_neighbors) for n_neighbors in range(1, 10)] print(len(Y)) . #solution 3 ranges = [round(max(x)-min(x),2) for x in Y] print(ranges) . References . References . python4datascience-atc | PythonDataScienceHandbook | DS-python-data-analysis | Working With Files in Python | . &lt;/div&gt; . | . | . | . | .",
            "url": "https://sambaiga.github.io/sambaiga/python/2019/04/01/python-basics.html",
            "relUrl": "/python/2019/04/01/python-basics.html",
            "date": " • Apr 1, 2019"
        }
        
    
  
    
        ,"post7": {
            "title": "Variational Inference (VI)",
            "content": "The bayesian method offers a different paradigm for doing statistical analysis. It is a practical method for making inferences from data using probability models. Unlike other analytical approaches, Bayesian models are easy to interpret and incorporate uncertainty. In the Bayesian method we start with a belief which is also called a prior. We then update our belief after observing some data. The outcome is called a posterior. The process repeats as we keep on seeing more data where the old posterior becomes a new prior. The method employs the Bayes rule. . Consider the Bayesian theorem, which allows us to use some knowledge or belief that we already have. Given data point $ mathcal{D} = {x in mathbb{R}^{N times d}, y in mathbb{R}^{N times c} }$. The Bayesian approach treats the latent variable or parameter $z$ as a random variable with some prior distribution $p(z)$. This is the probability of parameters $z$ beforehand. . $$ p(z | mathcal{D} ) = frac{p( mathcal{D} | z ) cdot p(z)}{p( mathcal{D})} $$where . $$ p( mathcal{D}) = int p( mathcal{D} |z ) cdot p(z) dz $$From the bayesian theorem above, $z$ is the hypothesis about the world, and $$ mathcal{D}$$ is the data or evidence. The probability $p( mathcal{D} mid z)$ is called likeli-hood; the probability of data given the latent variable and $p( mathcal{D})$ is the marginal-likelihood and $p(z mid mathcal{D} )$ is the posterior. . Bayesian Inference . Given data set $ mathcal{D}$ and latent variable $z$ that relate $x$ and $y$ such that: $$ y = f_{z}(x:z) $$ The first step in Bayesian inference is to identify the parameter $z$ and express our lack of knowledge about this parameter in terms of probability distribution $p(z)$. This is the prior knowledge about the parameter $z$. After that we express a likelihood $p( mathcal{D} mid z)$ which tell us how the data $ mathcal{D}$ interact with parameter $z$. Together the prior and the likelihood make our model (generative model). It tells us how we can simulate our data. . In training stage we apply Bayesian theorem to get posterior distribution: . $$ p(z| mathcal{D}) = frac{p( mathcal{D}|, z)}{p( mathcal{D})} $$ . In the testing stage, we find predictive-distribution . $$ p( hat{y}| x, mathcal{D}) = int p( hat{y} | x, z) cdot p(z | x, y) dz $$ $y= f_{ theta}(x: theta) + in $ where $ in$ is the noise due to measurement and $f_{ theta}(X: theta)$ is the hypothesis function given; $ f_{ theta}(X: theta) = b + sum_{i=1}^N w_i phi (x_i) = theta^T cdot phi(X) $ . where $ phi(X)$ is the basis function and $ theta$ is the model parameters such that $ theta_{0} =b$$ and $$ phi_0=1 $ . The output of this model is the single point estimate for the best model parameter. The Bayesian modelling approach to this problem offer a systematic framework for learning distribution over values of the parameters and not a single estimate. The bayesian linear regression model $y= f_{ theta}(x: theta) + in $ as a Gaussian distribution such that: $ p(y|x, theta) = mathcal{N}(y|f_{ theta}(x: theta), beta^{-1}) $ . Assuming the data point are drawn independently and identically distributed the likelihood is expressed as: . $$ p(Y| X, theta) = prod_{i=1}^N mathcal{N}(y_i|f_{ theta}(x_i: theta_i), beta^{-1}) $$Let choose a prior that is conjugate to the likelihood . $$ p( theta|X) = mathcal{N}( theta|0, alpha^{-1}) $$Thus the posterior is given as: . $$ p( theta|Y, X) propto mathcal{N}( theta|0, alpha^{-1}) cdot prod_{i=1}^N mathcal{N}(y_i|f_{ theta}(x_i: theta_i), beta^{-1}) $$ Variational Inference (VI) . In the previous section we show that inference in probabilist model is often intractable and introduced several approach used to approximate the inference. Variational Inference (VI) is one of the approach used to approximate difficult probability distribution by turning the calculation about model into optimization. . Consider a probabilistic model which is joint distribution $p(x,z)$ of the latent variable $$z$$ observed variables $x$. To draw inference on the latent variable $z$ we compute the posterior . $$ p(z|x) = frac{p(x,z)}{p(x)} = frac{p(x|z) cdot p(z)}{p(x)} $$where $ p(x)= int p(x|z) cdot p(z) dz $ To approximate $p(z mid x)$ we first choose an approximating family of distribution $q(z)$ over latent variable $z$. Then we find set of parameters that makes $q(z)$ close to posterior distribution $p(z mid { bf x})$. Thus VI approximate $p(z mid x)$ with new distribution $q(z)$ such that $q(z)$ is close to $p(z mid x)$. To achieve this we minimize KL divergence between $q(z)$ and $p(z mid x)$ such that: . $$ q^*(z) = arg min D_{KL}(q(z)||p(z|x)) $$where $ D_{KL}(q(z)||p(z|x)) = int q(z) log frac{q(z)}{p(z|x)} $ . It clear that we can not minimize KL divergence since it is directly depend on posterior $p(z mid x)$. However we can minimize a function that is equal to KL divergence plus constant. This function is called Evidence Lower Bound(ELBO) $ mathcal{L}_{VI}(q)$. . Evidence Lower Bound (ELBO) . To derive the ELBO we first consider the Jensen&#39;s inequality which relates the value of a convex function of an integral to the integral of the convex function such that $f( mathbb{E}[x]) geq mathbb{E}[f(x)]$ where $f(.)$ is the concave function. Since logarithmic are strictly concave function it is clear that . $$ log int p(x)g(x) dx geq int p(x) log g(x) $$Let us consider a log of marginal evidence. . $$ begin{aligned} log p(x) &amp; = log int_z p(x,z) dz &amp; = log int_z p(x,z) cdot frac{q(z)}{q(z)} dz &amp; = log int_z q(z) frac{p(x,z)}{q(z)} dz &amp; = log left( mathbb{E}_q[ frac{p(x,z)}{q(z)}] right) &amp; geq mathbb{E}_q[ log p(x,z)] - mathbb{E}_q[ log q(z)] end{aligned} $$The final line is the ELBO which is the lower bound for the evidence. Thus the evidence lower bound for probability model $$p(x,z)$$ and approximation $$q(z)$$ to the posterior is . $$ mathcal{L}_{VI}(q) = mathbb{E}_q[ log p(x,z)] - mathbb{E}_q[ log q(z)] $$We can now show that KL divergence to the posterior is equal to the negative ELBO plus constant. . $$ begin{aligned} D_{KL}(q(z)||p(z|x)) &amp;= int q(z) log frac{q(z)}{p(z|x)} &amp;= mathbb{E}_q[ log q(z)] - mathbb{E}_q[ log p(x,z)] + mathbb{E}_q[ log p(x)] &amp;=- left( mathbb{E}_q[ log p(x,z)] - mathbb{E}_q[ log q(z)] right) + log p(x) &amp;= - mathcal{L}_{VI}(q) + log p(x) mathcal{L}_{VI}(q) &amp;= log p(x) + D_{KL}(q(z)||p(z|x)) end{aligned} $$From the equation above it clear that minimizing the KL divergence is equivalent to maximizing the ELBO. Recall that we want to find $$q(z)$$ such that KL divergence is small, the variational objective function becomes . $$ q^*(z) = arg min D_{KL}(q(z)||p(z|x)) = arg max mathcal{L}_{VI}(q) $$Mean Field Variational Inference . One of the important question on VI, is how to construct the family of variational distributions from which we want to draw $q(z)$ from. The simplest family is where each latent parameter $z_i$ has its own independent distribution. This means that we can easily factorize the variational distributions into groups: . $$ q(z_1, ldots, z_m) = prod_{i=1}^m q(z_i) $$This family of distribuion are known as Mean-Field Variational Family that make use of mean field theory. Inference using this factorization is known as Mean-Field Variational Inference (MFVI). . It possible to further parameterize the approximating distributions $q(z)$ with variational parameters $ lambda$ such that the approximating distribution become $q(z_i ; lambda_i)$. For example if we set our family of approximating distributions as a set of independent gauasian distributions $ mathcal{N}( mu_i, sigma^2_i)$ and parameterize this distributions with the mean and variance where $ lambda_i = ( mu_i, sigma^2_i)$ is the set of variational parameters. . The common algorithms used in practise to do VI under mean filed assumptions are coordinate ascent optimization (CAVI) and stochastic gradient based method. . Coordinate Ascent Variational Inference (CAVI) . The CAVI algorithm derive variational updates by hand and perform coordinate ascent (iteratively updating each latent variable $z_i$) on the latent until convergence of the ELBO. A common procedure to conduct CAVI is: . Choose variational distributions $q(z)$ | Compute ELBO; | Optimize individual $q(z_i)$ ’s by taking the gradient for each latent variable; | Repeat until ELBO converges. | . The coordinate ascent update for a latent variable can be derived by maximizing the ELBO function above. First, recall ELBO . $$ mathcal{L}_{VI}(q) = mathbb{E}_q[ log p(x,z)] - mathbb{E}_q[ log q(z)] $$ Applying chain rule we can decomopse the joint $p(x,z)$ as; $$ p(x_{1:n}, z_{1:m}) = p(x_{1:n}) prod_{i=1}^m p(z_i|z_{1:(i-1)}, x_{1:n}) $$ Using mean field approximation, we can decompose the entropy term of the ELBO as $$ mathbb{E}_q[ log q(z)] = sum_{i=1}^m mathbb{E}_q[ log q(z_i)] $$ Under the above assumption the ELBO become: $$ mathcal{L}_{ELBO}(q) = log p(x_{1:n}) + sum_{i=1}^m mathbb{E}_q[ log p(z_i|z_{1:(i-1)}, x_{1:n}) ] - mathbb{E}_q[ log q(z_i) $$ . To find this $ arg max_{q(z_i)} mathcal{L}_{ELBO}(q)$ we take derivative of ELBO with respect to $q(z_i)$ using Lagrange multipliers and set the derivative to zero. It can be shown that the coordinate ascent update rule is equal to . $$ q^*(z_i) propto { mathbb{E}_{q-i}[ log q(z_i,z_{ neg},x)] } $$where the notation $ neg$ denotes all indices other than the $i^{th}$ . Despite being very fast method for some models only work with conditionally conjugate models. . Reference . ICML 2018 tutorial:Variational Bayes and Beyond: Bayesian Inference for Big Data. | Shakir Mohamed:Variational Inference for Machine Learning. | DS3 workshop:Approximate Bayesian Inference: Old and New. | Variational Inference and Deep Generative Models:Variational Inference for NLP audiences |",
            "url": "https://sambaiga.github.io/sambaiga/statistical%20inference/generative%20models/machine%20learning/2019/03/02/bayes-vi.html",
            "relUrl": "/statistical%20inference/generative%20models/machine%20learning/2019/03/02/bayes-vi.html",
            "date": " • Mar 2, 2019"
        }
        
    
  
    
        ,"post8": {
            "title": "Learning from probabilistic models",
            "content": "Introduction . Given some data $ mathbf{x}=[x_1 ldots x_m]$ that come from some probability density function characterized by an unknown parameter $ theta$. How can we find $ hat{ theta}$ that is the best estimator of $ theta$. For example suppose we have flipped a particular coin $ 100$ times and landed head $ N_H = 55$ times and tails $ N_T = 45$ times. We are interested to know what is the probability that it will come-up head if we flip it again. In this case the behavior of the coin can be summerized with parameter $ theta$ the probability that a flip land head (H), which in this case is independent and identically distributed Bernoulli distribution. The key question is, how do we find parameter $ hat{ theta}$ of this distribution that fits the data. This is called parameter estimation, in which three approaches can be used: . Maximum-Likehood estimation | Bayesian parameter estimation and | Maximum a-posterior approximation | Like-hood and log-likehood function . Before discussing the above learning approach, let firts define the like-hood function $L( theta)$ which is the probability of the observed data as function of $ theta$ given as: . $$ L( theta) = P(x_1, ldots x_m; theta) = prod_i^m P(x_i; theta) $$The like-hood function indicates how likely each value of the parameter is to have generated the data. In the case of coin example above, the like-lihood is the probability of particular seqeuence of H and T generated: . $$ L( theta) = theta ^{N_H}(1 - theta ^{N_T}) $$ . We also define the log-likelihood function $ mathcal{L}( theta)$ which is the log of the likelihood function $L( theta)$. . $$ begin{aligned} mathcal{L}( theta) &amp;= log L( theta) &amp; = log prod_i^m P(x_i; theta) &amp; = sum_i^M P(x_i; theta) end{aligned} $$For the above coin example the log-likelihood is . $$ mathcal{L}( theta)= N_H log theta + N_T log(1- theta) $$ Maximum-Likelihood Estimation . The main objective of maximum likelihood estimation (MLE) is to determine the value of $ theta$ that is most likely to have generated the vector of observed data, $ mathbf{x}$ where $ theta$ is assumed to be fixed point (point-estimation). MLE achieve this by finding the parameter that maximize the probability of the observed data. The parameter $ hat{ theta}$ is selected such that it maximize $ mathcal{L}( theta)$: . $ hat{ theta}= arg max_{ theta} mathcal{L}( theta) $ . For the coin example the MLE is : . $$ begin{aligned} frac{ partial mathcal{L}( theta)}{ partial theta} &amp; = frac{ partial }{ partial theta}(N_H log theta + N_T log(1- theta) &amp;= frac{N_H}{ theta} - frac{N_T}{1- theta} end{aligned} $$Set $ frac{ partial mathcal{L}( theta)}{ partial theta} = 0$ and solve for $ theta$ we obtain the MLE: . $ hat{ theta} = frac{N_H}{N_H + N_T} $ . which is simply the fraction of flips that cameup head. . Now suppose we are observing power-meta data which can be modelled as gaussian ditribution with mean $$ mu$$ and standard deviation $ sigma$. We can use MLE to estimate $ hat{ mu}$ and $ hat{ sigma}$. The log-likehood for gausian distribution is given as . $$ begin{aligned} mathcal{L}( theta) &amp;= sum_{i=1}^M log left[ frac{1}{ sqrt{2} pi sigma} exp frac{-(x_i - mu)}{2 sigma ^2} right] &amp; = - frac{M}{2} log 2 pi - M log sigma - frac{1}{2 sigma^2} sum_i^M (x_i - mu)^2 end{aligned} $$Let find $ frac{ partial mathcal{L}( theta)}{ partial mu} $ and $ frac{ partial mathcal{L}( theta)}{ partial sigma} $ and set equal to zero. . $$ begin{aligned} frac{ partial mathcal{L}( theta)}{ partial mu} &amp;= - frac{1}{2 sigma^2} sum_i^M frac{ partial}{ partial mu}(x_i - mu)^2 &amp; = sum_i^M (x_i - mu) = 0 &amp; Rightarrow hat{ mu} = frac{1}{M} sum_{i=1}^M x_i end{aligned} $$which is the mean of the observed values. Similary: . $$ begin{aligned} frac{ partial mathcal{L}( theta)}{ partial sigma} &amp;= frac{M}{ sigma} + frac{1}{ sigma^3} sum_i^M (x_i - mu)^2 &amp; Rightarrow hat{ sigma} = sqrt{ frac{1}{M} sum_{i=1}^M (x_i - mu)^2} end{aligned} $$In the two examples above we manged to obtain the exact maximum likelihood solution analytically. But this is not always the case, let’s consider how to compute the maximum likelihood estimate of the parameters of the gamma distribution, whose PDF is defined as: . $$ P(x) = frac{b^a}{ Gamma(a)}x^{x-1} exp(-bx) $$where $ Gamma (a)$ is the gamma function which is the generalization of the factorial function to continous values given as: . $ Gamma(t) = int_0^{- infty} x^{t-1} exp(-x) ,dx $ . The model parameters for gamma distribution is $a$ and $b$ both of which are $ geq 0$. the log-likelihood is therefore: . $ begin{aligned} mathcal{L}( a, b) &amp; = sum_{i=1}^M a log b - log Gamma (a) + (a -1) log x_i - bx_i &amp; = Ma log b - M log Gamma (a) + (a - 1) sum_{i=1}^M log x_i - b sum_{i=1}^M x_i end{aligned} $ . To get MLE we need employ gradient descent which consists of computing the derivatives: $ frac{ partial mathcal{L}}{ partial a} $ and $ frac{ partial mathcal{L}}{ partial b} $ and then updating; $ a_{k+1}= a_k + alpha frac{ partial mathcal{L}}{ partial a} $ and $ b_{k+1}= b_k + alpha frac{ partial mathcal{L}}{ partial b} $ . where $ alpha$ is the learning rate. . Limitation of MLE . Despite the fact that MLE is very powerful technique, it has a pitfall for little training data which can lead into seriously overfit. The most painful issue is when it assign a $0$ probability to items that were never seen in the training data but which still might actually happen. Take an example if we flipped a coin twice and $N_H = 2$, the MLE of $ theta$, the probability of H would be $1$. This imply that we are considering it impossible for the coin to come up T. This problem is knowas data sparsity. . Bayesian Parameter Estimation . Unlike MLE which treat only the observation $ mathbf{x}$ as random variable and the parameter $ theta$ as a fixed point, the bayesian approach treat the parameter $ theta $ as random varibale as well with some known prior distribution. Let define the model for joint distribution $$p( theta, mathcal{D})$$ over parameter $ theta$ and data $ mathcal{D}$. To further define this joint distribution we aslo need the following two distribution: . A distribution of $P( theta)$ knowas prior distribution which is the probability of paratemeter $ theta$ availabe beforehand, and before making any additional observations. It account for everything you believed about the parameter $ theta$ before observing the data. In practise choose prior that is computational convinient. . | The likelihood $P( mathcal{D} mid theta)$ which is the probability of data given the parameter like in maximum likelihood. . | . With this two distributions, we can compute the posterior distribution and the posterior predictive distribution. The posterior distribution $P( theta mid mathcal{D})$ which correspond to uncertainty about $ theta$ after observing the data given by: . $$ begin{aligned} P( theta mid mathcal{D}) &amp;= frac{P( theta)p( mathcal{D} mid theta)}{P( mathcal{D})} &amp;= frac{P( theta)P( mathcal{D} mid theta)}{ displaystyle int P( theta ^ { prime} ) P( mathcal{D} mid theta ^{ prime})} end{aligned} $$The denominator is usually considered as a normalizing constant and thus the posterior distribution become: . $$ P( theta mid mathcal{D}) propto P( theta)P( mathcal{D} mid theta) $$On the other hand the posterior predictive distribution $P( mathcal{D}^{ prime} mid) mathcal{D}$ is the distribution of future observation given past observation defined by: . $$ P( mathcal{D}^{ prime} mid mathcal{D} )= int P( theta mid mathcal{D}) P( mathcal{D}^{ prime} mid theta) $$Generaly the Bayesian approach to parameter estimation works as follows: . First we need to formulate our knowledge about a situation by defining a distribution model which expresses qualitative aspects of our knowledge about the situation and then specify a prior probability distribution which expresses our subjective beliefs and subjective uncertainty about the unknown parameters, before seeing the data. | Gather data | Obtain posterior knowledge that updates our beliefs by computing the posterior probability distribution which estimates the unknown parameters. | Let apply the bayesian estimation to the coin example in which we have specified the likelihood equal to $ theta^{N_H}(1- theta)^{N_T}$. We only required to specify the prior in which several approches can be used. One of the approach is relay upon lifetime experince of flipping coins in which most coins tend to be fair which implies $p( theta) = 0.5$. We can also use various distribution to specify prior density but in practise a most useful distribution is the beta distribution parameterized by $a , b &gt; 0$ and defined as: . $$ p( theta; a, b) = frac{ Gamma (a + b)}{ Gamma(a) Gamma (b)} theta ^{a-1}(1- theta ^{b - 1}) $$From the above eqution it is clear that the first term (with all $ Gamma$)is just a normalizing constant and thus we can rewrite the beta distribution as: . $$ p( theta; a, b) propto theta ^{a-1}(1- theta) ^{b - 1} $$Note the beta distribution has the following properties . It is centered around $ frac{a}{a + b}$ and it can be shown that if $ theta sim text{Beta}(a,b)$ then $ mathbb{E}( theta)= frac{a}{a + b}$. | It becomes more peaked for larger values of $a$ and $b$ | It become normal distribution when $a = b = 1$ | . Now let compute the posterior and posterior predictive distribution . $$ begin{aligned} p( theta | mathcal{D}) &amp; propto p( theta)p( mathcal{D} | theta) &amp; propto theta^{N_H}(1- theta)^{N_T} theta ^{a-1}(1- theta) ^{b - 1} &amp; = theta ^{a-1+N_H}(1- theta) ^{b - 1 + N_T} end{aligned} $$",
            "url": "https://sambaiga.github.io/sambaiga/machine%20learning/data%20science/probability/2018/04/02/probabilities-learning.html",
            "relUrl": "/machine%20learning/data%20science/probability/2018/04/02/probabilities-learning.html",
            "date": " • Apr 2, 2018"
        }
        
    
  
    
        ,"post9": {
            "title": "Basics of Probability and Information Theory",
            "content": "Introduction . Probability and Information theory are important field that has made significant contribution to deep learning and AI. Probability theory allows us to make uncertain statements and to reason in the presence of uncertainty where information theory enables us to quantify the amount of uncertainty in a probability distribution. . Probability Theory . Probability is a mathematical framework for representing uncertainty. It is very applicable in Machine learning and Artificial Intelligence as it allows to make uncertain statements and reason in the presence of uncertainty. Probability theory allow us to design ML algorithms that take into consideration of uncertain and sometimes stochastic quantities. It further tell us tell us how ML systems should reason in the presence of uncertainty. This is necessary because most things in the world are uncertain, and thus ML systems should reason using probabilistic rules. Probability theory can also be used to analyse the behaviour of ML algorithms probabilistically. Consider evaluating ML classification algorithm using accuracy metric which is the probability that the model will give a correct prediction given an example. . Probability and Probability distribution . Probability is a measure of the likelihood that an event will occur in a random experiment. It is quantified as number between 0 and 1. The mathematical function that maps all possible outcome of a random experiment with its associated probability it is called probability distribution. It describe how likely a random variable or set of random variable is to take on each of its possible state. The probability distribution for discrete random variable is called probability mass function (PMF) which measures the probability $X$ takes on the value $x$, denoted denoted as $P(X=x)$. To be PMF on random variable $X$ a function $P(X)$ must satisfy: . Domain of $P$ equal to all possible states of $X$ | $ forall x in X, 0 leq P(X=x) leq 1$ | $ sum_{x in X} P(x) =1$ | . Popular and useful PMF includes poison, binomial, bernouli, and uniform. Let consider a poison distribution defined as: . $$ P(X=x) = frac{ lambda ^x e^{ - lambda}}{x!} $$$ lambda &gt;0$ is called a parameter of the distribution, and it controls the distribution&#39;s shape. By increasing $ lambda$ , we add more probability to larger values, and conversely by decreasing $ lambda$ we add more probability to smaller values as shown in figure below. . Instead of a PMF, a continuous random variable has a probability density function (pdf) denoted as $f_X(x)$. An example of continuous random variable is a random variable with exponential density. $$ f_X(x mid lambda) = lambda ^x e^{ - lambda} text{, } x geq 0 $$ . To be a probability density function $p(x)$ must satisfy . The domain of $p$ must be the set of all possible state | $ forall x in X, f_X(x) geq 0$ | $ int_{x in X} f_X(x)dx =1$ | . The pdf does not give the probability of a specific state directly. The probability that $x$ is between two point $a, b$ is . $ int_{a}^b f_X(x)dx$ . The probability of intersection of two or more random variables is called joint probability denoted as $ P(X, Y) $ . Suppose we have two random variable $X$ and $Y$ and we know the joint PMF or pdf distribution between these variable. The PMF or pdf corresponding to a single variable is called marginal probability distribution defined as $$ P(x) = sum_{y in Y} P(x, y) $$ . for discrete random variable and $$ p(x) = int p(x)dy $$ . Marginalization allows us to get the distribution of variable $$X$$ ignoring variable $Y$ from the joint distribution $P(X,Y)$. The probability that some event will occur given we know other events is called condition probability denoted as $P(X mid Y)$. The marginal, joint and conditional probability are linked by the following rule $ P(X|Y) = frac{P(X, Y)}{P(Y)} $ . Independence, Conditional Independence and Chain Rule . Two random variables are said to be independent of each other if the probability that one random variables occur in no way affect the probability of the other random variable occurring. $X$ and $Y$ are said to be independent if $P(X,Y) = P(X) cdot P(Y)$ On the other hand two random variable $X$ and $Y$ are conditionally independent given an event $Z$ with $P(Z)&gt;0$ if . $$ P(X,Y mid Z) = P(X mid Y) cdot P(Y mid Z) $$The good example of conditional independence can be found on this link. Any joint probability distribution over many random variables may be decomposed into conditional distributions using chain rule as follows: . $$ P(X_1,X_2, ldots, X_n ) = P(X_1) prod_{i=2}^n P(X_i mid X_i, ldots X_{i-1}) $$Expectation, Variance and Covariance . Expected value of some function $f(x)$ with respect to a probability distribution $P(X)$ is the average or mean value that $f(x)$ takes on when $x$ is drawn from $P$. . $$ mathbb{E}_{x sim P}[f(x)] = sum P(x).f(x) $$for discrete random variable and . $$ mathbb{E}_{x sim P}[f(x)] = int P(x).f(x)dx $$Expectation are linear such that $$ mathbb{E}_{x sim P}[ alpha cdot f(x) + beta cdot g(x)] = alpha mathbb{E}_{x sim P}[f(x)] + beta mathbb{E}_{x sim P}[g(x)] $$ . Variance is a measure of how much the value of a function of random variable $X$ vary as we sample different value of $x$ from its probability distribution. $$ Var(f(x)) = mathbb{E}([f(x)- mathbb{E}[f(x)]^2]) $$ The square root of the variance is know as standard deviation. On the other hand the covarince give some sense of how much two value are linearly related to each other as well as the scale of these value. . $$ Cov(f(x), g(y)) = mathbb{E}[(f(x)- mathbb{E}[f(x)])(g(y)- mathbb{E}[g(y)])] $$ Information theory . Information theory deals with quantification of how much information is present in a signal. In context of machine learning, information theory we apply information theory to: characterize probability distributions and quantify similarities between probability distributions. The following are the key information concepts and their application to machine learning. . Entropy, Cross Entropy and Mutual information . Entropy give measure of uncertainty in a random experiment. It help us quantify the amount of uncertainty in an entire probability distribution. The entropy of a probability distribution is the expected amount of information in an event drawn from that distribution defined as. . $$ H(X) = - mathbb{E}_{x sim P}[ log P(x)] = - sum_{i=1}^n P(x_i)l log P(x_i) $$Entropy is widely used in model selection based on principle of maximum entropy. On the other hand, cross entropy is used to compare two probability distribution. It tell how similar two distribution are. The cross entropy between two probability distribution $P$ and $$Q$ defined over same set of outcome is given by . $$ H(P,Q)= - sum P(x) log Q(x) $$ . Cross entropy loss function is widely used in machine learning for classification problem. The mutual information over two random variables help us gain insight about the information that one random variable carries about the other. . $$ begin{aligned} I(X, Y) &amp;= sum P(x, y) log frac{P(x,y)}{P(x).P(y)} &amp;=H(X)- H(X mid Y) = H(Y) - H(Y mid X) end{aligned} $$From above equation the mutual information give insight about how far $X$ and $Y$ from being independent from each other. Mutual information can be used in feature selection instead of correlation as it capture both linear and non linear dependency. . Kullback-leibler Divergence . Kullback-leibler Divergence measure how one probability distribution diverge from the other. Given two probability distribution $P(x)$ and $Q(X)$ where the former is the modelled/estimated distribution and the later is the actual/expected distribution. The KL divergence is defined as . $$ begin{aligned} D_{KL}(P||Q) &amp; = mathbb{E}_{x sim P} [ log frac{P(x)}{Q(x)}] &amp; = mathbb{E}_{x sim P}[ log P(x)] - mathbb{E}_{x sim P}[ log Q(x)] end{aligned} $$For discrete random distribution . $$ D_{KL}(P||Q) = sum_{i} P(x_i) log frac{P(x_i)}{Q(x_i)} $$And for continuous random variable . $$ D_{KL}(p||q) = int_{x} p(x) log frac{p(x)}{q(x)} $$KL divergence between $P$ and $Q$ tells how much information we lose when trying to approximate data given by $P$ with $Q$. It is non-negative $D_{KL}(P mid mid Q) geq 0$ and $0$ if $P$ and $Q$ are the same (distribution discrete) or equal almost anywhere in the case of continuous distribution. Apart from that KL divergence is not symmetric $D_{KL}(P mid mid Q) neq D_{KL}(P mid mid Q)$ because of this it is not a true distance measure. . Relation between KL divergence and Cross Entropy . $$ begin{aligned} D_{KL}(P||Q) &amp; = mathbb{E}_{x sim P} [ log frac{P(x)}{Q(x)}] &amp; = mathbb{E}_{x sim P}[ log P(x)] - mathbb{E}_{x sim P}[ log Q(x)] &amp; = H(P) - H(P, Q) end{aligned} $$where $ mathbb{E}_{x sim P}[ log P(x)] = H(P)$$ and $$ mathbb{E}_{x sim P}[ log Q(x)] = H(P, Q)$. Thus $H(P,Q) = H(P) - D_{KL}(P||Q)$. This implies that minimizing cross entropy with respect to $Q$ is equivalent to minimizing the KL divergence. KL divergence is used in unsupervised machine learning technique like variational auto-encoder. The KL divergence is also used as objective function in variational bayesian method to find optimal value for approximating distribution. .",
            "url": "https://sambaiga.github.io/sambaiga/machine%20learning/data%20science/2018/02/01/probabilities.html",
            "relUrl": "/machine%20learning/data%20science/2018/02/01/probabilities.html",
            "date": " • Feb 1, 2018"
        }
        
    
  
    
        ,"post10": {
            "title": "Mixture Density Networks.",
            "content": "Introduction . Deep Learning models are widely used in prediction problem which involves learning the mapping from a set of inputs variables x={x1,…,xd} mathbf{x}= {x_1, ldots, x_d }x={x1​,…,xd​} to a set of output variables y={y1,…,yc} mathbf{y}= {y_1, ldots,y_c }y={y1​,…,yc​}. In this setting, ddd is the size of input features, and ccc is the dimension of the output feature or target. In this case, usually the network is trained using minimization of the sum of squares errors or cross-entropy error function over a set of training data {x1:N,y1:N} { mathbf{x}_{1:N}, mathbf{y}_{1:N} }{x1:N​,y1:N​} of the form . L=(y−y^)2 where y^1:c=f(x1:d,w,b) mathcal{L} = ( mathbf{y}- hat mathbf{y})^2 text{ where } hat mathbf{y}_{1:c}=f( mathbf{x}_{1:d}, mathbf{w, b})L=(y−y^​)2 where y^​1:c​=f(x1:d​,w,b) . With this approach it is explicitly assumed that there is a deterministic 1−to−11-to-11−to−1 mapping between a given input variables x={x1,…,xd} mathbf{x}= {x_1, ldots, x_d }x={x1​,…,xd​} and target variable y={y1,…,yc} mathbf{y}= {y_1, ldots,y_c }y={y1​,…,yc​} without any uncertainty. As the result, the output of the network trained by this approach approximates the conditional mean of the output in the training data conditioned on the input vector. For classification problems with a well-chosen target coding scheme, these averages represent the posterior probability of class membership and thus be regarded as optimal. For a problem involving the prediction of a continuous variable, especially the conditional averages is not usually a good description of data and don’t have power to the modal distribution of output with complex. One way to solve this problem is to model the complete conditional probability density instead. This is the approach used by Mixture Density Networks (MDN). . Mixture Density Network . An MDN, as proposed by Bishop, is a flexible framework for modeling an arbitrary conditional probability distribution p(y∣x)p( mathbf{y}| mathbf{x})p(y∣x) as a mixture of distributions. It combines a mixture model with DNN in which a DNN is used to parametrize a mixture model consisting of some predefined distributions. Considering gaussian distribution, DNN is used to map a set of input features x1:d mathbf{x}_{1:d}x1:d​ to the parameters of a GMM i.e mixture weights πk(x) pi_k( mathbf{x})πk​(x), mean μk(x) mu _k( mathbf{x})μk​(x) and the covariance matrices σk2(x) sigma_k^2( mathbf{x})σk2​(x) which in turn gives a full probability density function of an output feature y mathbf{y}y conditioned on the input features. . p(y∣x)=∑k=1Mπk(x)N(y;μk(x),σk2(x))p( mathbf{y}| mathbf{x})= sum_{k=1}^M pi_k( mathbf{x}) mathcal{N}( mathbf{y}; mu_k( mathbf{x}), sigma_k^2( mathbf{x}))p(y∣x)=k=1∑M​πk​(x)N(y;μk​(x),σk2​(x)) . where MMM is the number of components in the mixture and . N(y;μk(x),σk2(x))=1(2σk2(x))c/2exp⁡[∣∣y−μk(x)∣∣22σk2(x)] mathcal{N}( mathbf{y}; mu_k( mathbf{x}), sigma_k^2( mathbf{x})) = frac{1}{(2 sigma_k^2( mathbf{x}))^{c/2}} exp left[ frac{|| mathbf{y}- mu_k( mathbf{x})||^2}{2 sigma_k^2( mathbf{x})} right]N(y;μk​(x),σk2​(x))=(2σk2​(x))c/21​exp[2σk2​(x)∣∣y−μk​(x)∣∣2​] . The mixture weights πk(x) pi_k( mathbf{x})πk​(x) represents the relative amounts by of each mixture components, which can be interpreted as the probabilities of the k−k-k− components for a given observation x mathbf{x}x.If we introduce a latent variable z mathbf{z}z with kkk possible states, then πk(x) pi_k( mathbf{x})πk​(x) will represents the probability distribution of these states p(z)p( mathbf{z})p(z). Specifically, the MDN converts the input vector using DNN with an output layer z mathbf{z}z of linear units to obtain the output z^=f(x,θ) hat{ mathbf{z}} = f( mathbf{x}, mathbf{ theta})z^=f(x,θ) . The total number of networks outputs i.e the dimension of z^ is (c+2)⋅M hat{ mathbf{z}} text{ is } (c+2) cdot Mz^ is (c+2)⋅M compared to the usual ccc outputs for a network used in the conventional manner. In order to guarantee that p(y∣x)p( mathbf{y}| mathbf{x})p(y∣x) is a probability distribution, the outputs of the networks need to be constrained such that the variance should remain positive and the mixing coefficients lie between zero and one and sum to one. To achieve these constraints: . The mean of the k−thk-thk−th kernel is modeled directly as the network outputs: | . μki(x)=zkμi where i=1,…,c mu_{k}^i( mathbf{x})=z_{k}^{ mu i} text{ where } i = 1, ldots, cμki​(x)=zkμi​ where i=1,…,c . The variances of $$ sigma_k $ is represented by an exponential activation function of the corresponding network output. | . σk(x)=exp⁡(zkσ) sigma_k( mathbf{x}) = exp(z_k^{ sigma})σk​(x)=exp(zkσ​) . The mixing coefficient πk(x) pi _k( mathbf{x})πk​(x) is modeled as the softmax transformation of the corresponding output. | . πk=exp⁡(zkπ)∑j=1Mexp⁡(zjπ) pi_k = frac{ exp(z_k^{ pi})}{ sum_{j=1}^M exp(z_j^{ pi})}πk​=∑j=1M​exp(zjπ​)exp(zkπ​)​ . Training MDN . As the generative model, an MDN model can be trained using the backpropagation algorithm under the maximum likelihood criterion. Suppose θ thetaθ is the vector of the trainable parameter, and we can redefine our model as a function of x mathbf{x}x parameterized by θ thetaθ . p(y∣x,θ)=∑k=1Mπk(x,θ)N(y;μk(x,θ),σk2(x,θ))p( mathbf{y}| mathbf{x}, mathbf{ theta})= sum_{k=1}^M pi_k( mathbf{x}, mathbf{ theta}) mathcal{N}( mathbf{y}; mu_k( mathbf{x}, mathbf{ theta}), sigma_k^2( mathbf{x}, mathbf{ theta}))p(y∣x,θ)=k=1∑M​πk​(x,θ)N(y;μk​(x,θ),σk2​(x,θ)) . Considering a data set D={x1:N,y1:N} mathcal{D}= { mathbf{x}_{1:N}, mathbf{y}_{1:N} }D={x1:N​,y1:N​} we want to maximize . p(θ∣D)=p(θ∣Y,X)p( mathbf{ theta}| mathcal{D}) = p( mathbf{ theta}| mathbf{Y}, mathbf{X})p(θ∣D)=p(θ∣Y,X) . By Bayes’s theorem, this is equivalent to . p(θ∣Y,X)p(Y)=p(Y,θ∣X)=p(Y∣X,θ)p(θ)p( mathbf{ theta}| mathbf{Y}, mathbf{X})p( mathbf{Y}) = p( mathbf{Y}, mathbf{ theta} | mathbf{X}) = p( mathbf{Y}| mathbf{X}, mathbf{ theta})p( mathbf{ theta})p(θ∣Y,X)p(Y)=p(Y,θ∣X)=p(Y∣X,θ)p(θ) . which leads to . p(θ∣Y,X)=p(Y∣X,θ)p(θ)p(Y)∝p(Y∣X,θ)p(θ)p( mathbf{ theta}| mathbf{Y}, mathbf{X}) = frac{p( mathbf{Y}| mathbf{X}, mathbf{ theta})p( mathbf{ theta})}{p( mathbf{Y})} propto p( mathbf{Y}| mathbf{X}, mathbf{ theta})p( mathbf{ theta})p(θ∣Y,X)=p(Y)p(Y∣X,θ)p(θ)​∝p(Y∣X,θ)p(θ) where p(Y∣X,θ)=∏n=1Np(yn∣xn,θ)p( mathbf{Y}| mathbf{X}, mathbf{ theta})= prod_{n=1}^N p( mathbf{y}_n| mathbf{x}_n, mathbf{ theta})p(Y∣X,θ)=∏n=1N​p(yn​∣xn​,θ) which is simply the product of the conditional densities for each pattern. . To define an error function, the standard approach is the maximum likelihood method, which requires maximisation of the log-likelihood function or, equivalently, minimisation of the negative logarithm of the likelihood. Therefore, the error function for the Mixture Density Network is: . E(θ,D)=−log⁡p(θ∣Y,X)=−log⁡p(Y∣X,θ)p(θ)=−(log⁡∏n=1Np(yn∣xn,θ)+log⁡p(θ))=−(∑n=1Nlog⁡∑k=1Mπk(x)N(y;μk(x),σk2(x))+log⁡p(θ)) begin{aligned} E( theta, mathcal{D})&amp;=- log p( mathbf{ theta}| mathbf{Y}, mathbf{X})= - log p( mathbf{Y}| mathbf{X}, mathbf{ theta})p( mathbf{ theta}) &amp;= - left( log prod_{n=1}^N p( mathbf{y}_n| mathbf{x}_n, mathbf{ theta}) + log p( mathbf{ theta}) right) &amp;=- left( sum_{n=1}^N log sum_{k=1}^M pi_k( mathbf{x}) mathcal{N}( mathbf{y}; mu_k( mathbf{x}), sigma_k^2( mathbf{x})) + log p( mathbf{ theta}) right) end{aligned}E(θ,D)​=−logp(θ∣Y,X)=−logp(Y∣X,θ)p(θ)=−(logn=1∏N​p(yn​∣xn​,θ)+logp(θ))=−(n=1∑N​logk=1∑M​πk​(x)N(y;μk​(x),σk2​(x))+logp(θ))​ . If we assume a non-informative prior of p(θ)=1p( mathbf{ theta})=1p(θ)=1 the error function simplify to . E(θ,D)=−∑n=1Nlog⁡∑k=1Mπk(x)N(y;μk(x),σk2(x))E( theta, mathcal{D}) = - sum_{n=1}^N log sum_{k=1}^M pi_k( mathbf{x}) mathcal{N}( mathbf{y}; mu_k( mathbf{x}), sigma_k^2( mathbf{x}))E(θ,D)=−n=1∑N​logk=1∑M​πk​(x)N(y;μk​(x),σk2​(x)) .",
            "url": "https://sambaiga.github.io/sambaiga/machine%20learning/2018/01/03/mdn.html",
            "relUrl": "/machine%20learning/2018/01/03/mdn.html",
            "date": " • Jan 3, 2018"
        }
        
    
  
    
        ,"post11": {
            "title": "Introduction to Machine Learning - Classification.",
            "content": "Introduction . Previously we learned how to predict continuous-valued quantities as a linear function of input values. This post will describe a classification problem where the goal is to learn a mapping from inputs $x$ to target $t$ such that $t in {1 ldots C }$ with $C$ being the number of classes.If $C = 2$, this is called binary classification (in which case we often assume $y in {0, 1}$; if $C &gt; 2$, this is called multiclass classification. . We will first consider binary classification problem in which the target classes $t$ will be generated from 2 class distributions: blue ($t=1$) and red ($t=0$). Samples from both classes are sampled from their respective distributions. These samples are plotted in the figure below. . Note that $X$ is a $N times 2$ matrix of individual input samples $ mathbf{x}_i$, and that $ mathbf{t}$ is a corresponding $N times 1$ vector of target values $t_i$. . Logistic Regression . With logistic regression the goal is to predict the target class $t$ from the input values $x$. The network is defined as having an input $ mathbf{x} = [x_1, x_2]$ which gets transformed by the weights $ mathbf{w} = [w_1, w_2]$ to generate the probability that sample $ mathbf{x}$ belongs to class $t=1$$ This probability $P(t=1 mid mathbf{x}, mathbf{w})$ is represented by the output $y$ of the network computed as $y = sigma( mathbf{x} * mathbf{w}^T)$. $ sigma$ is the logistic function and is defined as: . σ(z)=11+e−z sigma(z) = frac{1}{1+e^{-z}}σ(z)=1+e−z1​ . which squashes the predictions to be between 0 and 1 such that: . P(t=1∣x,w)=y(σ(z))P(t=0∣x,w)=1−P(t=1∣x,w)=1−y(σ(z)) begin{aligned} P(t=1| mathbf{x}, mathbf{w}) &amp;= y( sigma(z))P(t=0 mid mathbf{x}, mathbf{w}) &amp;= 1 - P(t=1 mid mathbf{x}, mathbf{w}) = 1 - y( sigma(z)) end{aligned}P(t=1∣x,w)​=y(σ(z))P(t=0∣x,w)=1−P(t=1∣x,w)=1−y(σ(z))​ . The loss function for logistic function is called crossentropy and defined as: . LCE(y,t)={−log⁡yif t=1−log⁡(1−y)if t=0 mathcal{L}_{CE}(y,t)= begin{cases} - log y quad text{if } t = 1 - log (1-y) quad text{if } t = 0 end{cases}LCE​(y,t)={−logyif t=1−log(1−y)if t=0​ . The crossentropy can be written in other form as: . LCE(y,t)=−tlog⁡y−(1−t)log⁡(1−y) mathcal{L}_{CE}(y,t)= -t log y -(1-t) log(1-y)LCE​(y,t)=−tlogy−(1−t)log(1−y) . When we combine the logistic activation function with cross-entropy loss, we get logistic regression: . z=wTx+b y=σ(z) LCE(y,t)=−tlog⁡y−(1−t)log⁡(1−y) begin{aligned} z &amp; = mathbf{w^Tx + b} y &amp; = sigma(z) mathcal{L}_{CE}(y,t) &amp;= -t log y -(1-t) log(1-y) end{aligned}z y LCE​(y,t)​=wTx+b=σ(z)=−tlogy−(1−t)log(1−y)​ . The cost function with respect to the model parameters θ thetaθ (i.e. the weights and bias) is therefore: . εθ=1N∑i=1NLCE(y,t) =1N∑i=1N(−t(i)log⁡y(i)−(1−t(i))log⁡(1−y(i))) begin{aligned} varepsilon_{ theta} &amp; = frac{1}{N} sum_{i=1}^N mathcal{L}_{CE}(y,t) &amp; = frac{1}{N} sum_{i=1}^N left(-t^{(i)} log y^{(i)} -(1-t^{(i)}) log(1-y^{(i)}) right) end{aligned}εθ​ ​=N1​i=1∑N​LCE​(y,t)=N1​i=1∑N​(−t(i)logy(i)−(1−t(i))log(1−y(i)))​ . which can be implemented in python as follows: . # Define the cost function def cost(x, w, t): N, D = np.shape(x) z = z_value(x,w) y = y_value(z) result = np.sum(np.multiply(t, np.log(y)) + np.multiply((1-t), np.log(1-y)))/float(N) return -result . Gradient Descent for Logistic Function . To derive the gradient descent updates, we’ll need the partial derivatives of the cost function. We’ll do this by applying the Chain Rule twice: first to compute ∂LCE∂z frac{ partial mathcal{L}_{CE}}{ partial z}∂z∂LCE​​ and then again to compute $ frac{ partial mathcal{L}_{CE}}{ partial w_j}$ But first, let’s find $ frac{ partial y}{ partial z}$. . ∂y∂z=e−z(1+e−z)2=y(1−y) frac{ partial y}{ partial z} = frac{e^{-z}}{(1 + e^{-z})^2}= y(1-y)∂z∂y​=(1+e−z)2e−z​=y(1−y) . Now for the Chain Rule: . ∂LCE∂z=∂LCE∂y∂y∂z =(−ty+1−t1−y)y(1−y) =y−t begin{aligned} frac{ partial mathcal{L}_{CE}}{ partial z} &amp; = frac{ partial mathcal{L}_{CE}}{ partial y} frac{ partial y}{ partial z} &amp; = left( frac{-t}{y} + frac{1-t}{1-y} right) y(1-y) &amp;= y - t end{aligned}∂z∂LCE​​  ​=∂y∂LCE​​∂z∂y​=(y−t​+1−y1−t​)y(1−y)=y−t​ . Similary: . ∂LCE∂wj=∂LCE∂z∂z∂wj =∂LCE∂zxj =(y−t)xj begin{aligned} frac{ partial mathcal{L}_{CE}}{ partial w_j} &amp; = frac{ partial mathcal{L}_{CE}}{ partial z} frac{ partial z}{ partial w_j} &amp; = frac{ partial mathcal{L}_{CE}}{ partial z} x_j &amp;= (y - t)x_j end{aligned}∂wj​∂LCE​​  ​=∂z∂LCE​​∂wj​∂z​=∂z∂LCE​​xj​=(y−t)xj​​ . We can also obtain ∂LCE∂b frac{ partial mathcal{L}_{CE}}{ partial b}∂b∂LCE​​ as follows: . ∂LCE∂b=∂LCE∂z∂z∂b=(y−t) begin{aligned} frac{ partial mathcal{L}_{CE}}{ partial b} &amp;= frac{ partial mathcal{L}_{CE}}{ partial z} frac{ partial z}{ partial b} &amp; = (y-t) end{aligned}∂b∂LCE​​​=∂z∂LCE​​∂b∂z​=(y−t)​ . The gradient descent algorithm works by taking the derivative of the cost function εθ varepsilon_{ theta}εθ​ with respect to the parameters, and updates the parameters in the direction of the negative gradient.The parameter w mathbf{w}w is iteratively updated by taking steps proportional to the negative of the gradient: . wk+1=wk−α∂ε∂w mathbf{w_{k+1}} = mathbf{ w_k }- alpha frac{ partial mathbf{ varepsilon}}{ partial mathbf{w}}wk+1​=wk​−α∂w∂ε​ . where: . ∂LCE∂ε=∂ε∂LCE⋅∂LCE∂w=1NxT(y−t) begin{aligned} frac{ partial mathcal{L}_{CE}}{ partial varepsilon} &amp;= frac{ partial varepsilon }{ partial mathcal{L}_{CE}} cdot frac{ partial mathcal{L}_{CE}}{ partial mathbf{w}} &amp;= frac{1}{N} mathbf{x^T(y - t)} end{aligned}∂ε∂LCE​​​=∂LCE​∂ε​⋅∂w∂LCE​​=N1​xT(y−t)​ . which can be implemented in python as follows: . #gradient def gradient(x, w, t): z = z_value(x,w) y = y_value(z) error = y-t dw = x.T.dot(error) return dw.T def solve_gradient(x, t, alpha=0.1, tolerance=1e-2): N, D = np.shape(x) w = np.zeros([D]) iterations = 1 w_cost = [(w, cost(x,w, t))] while True: dw = gradient(x, w, t) w_k = w - alpha * dw w_cost.append((w, cost(x, w, t))) # Stopping Condition if np.sum(abs(w_k - w)) &lt; tolerance: print (&quot;Converged.&quot;) break if iterations % 100 == 0: print (&quot;Iteration: %d - cost: %.4f&quot; %(iterations, cost(x, w, t))) iterations += 1 w = w_k return w . Let us apply the above concept in the following example. Consider the case we want to predict whether a student with a specific pass mark can be admitted or not. . # load dataset admission = pd.read_csv(&#39;data/admission.csv&#39;, names = [&quot;grade1&quot;, &quot;grade2&quot;, &quot;remark&quot;]) admission.head() . The data-preprosessing is done using the following python code: . features = [&#39;grade1&#39;, &#39;grade2&#39;] target = [&#39;remark&#39;] targetVal = admission[target] featureVal = admission[features] y = np.array(targetVal) # Standardize the features for i in range(2): featureVal.iloc[:,i] = (featureVal.iloc[:,i] / featureVal.iloc[:,i].max()) # Add bias term to feature data b = np.ones((featureVal.shape[0], 1)) X = np.hstack((b, featureVal)) # randomly separate data into training and test data from sklearn.model_selection import train_test_split X_train, X_test, y_train, y_test = train_test_split( X, y, test_size=0.20, random_state=50) . We use the solve_gradient function defined before to find the parameter for logistic regression. . w_g = solve_gradient(X_train, y_train, alpha=0.05, tolerance = 1e-9) . Now that you learned the parameters of the model, you can use the model to predict whether a particular student will be admitted. . Let define the prediction function that only 1 or 0 depending on the predicted class. . def predict(x,w): z = z_value(x,w) y = y_value(z) return np.around(y) . To find the accuracy of the model: . p_test = predict(X_test, w_g) p_train = predict(X_train, w_g) print (&#39;Test Accuracy: %f&#39; % ((y_test[np.where(p_test == y_test)].size / float(y_test.size)) * 100.0)) print (&#39;Train Accuracy: %f&#39; % ((y_train[np.where(p_train == y_train)].size / float(y_train.size)) * 100.0)) . After running the above codes, we found that our model performs a training accuracy of 91.2591.2591.25 and a test accuracy of 858585 percents. . Multiclass classification . So far, we’ve talked about binary classification, but most classification problems involve more than two categories. Fortunately, this doesn’t require any new ideas: everything pretty much works by analogy with the binary case. The first question is how to represent the targets. We could describe them as integers, but it’s convenient to use indicator vectors or a one-of-K encoding. . Since there are $K$ outputs and DDD inputs, the linear function requires $K times D$ matrix as well as $K$ dimensional bias vector. We use softmax function which is the multivariate generalization given as: . yk=softmax(z1…zk)=ezk∑kezky_k = softmax(z_1 ldots z_k) = frac{e^{z_k}}{ sum_k e^{z_k}}yk​=softmax(z1​…zk​)=∑k​ezk​ezk​​ . and can be implemented in python as . def softmax(x,w): z = z_value(x,w) e_x = np.exp(x - np.max(x)) y = np.exp(z - max(z)) / np.sum(np.exp(z - max(z))) return y.reshape(len(y), 1) . Finally, the loss function (cross-entropy) for multiple-output case can be generalized as follows: . LCE(y,t)=−∑k=1Ktklog⁡yk=−tTlog⁡y begin{aligned} mathcal{L}_{CE}(y,t) &amp;= - sum_{k=1}^K t_k log y_k &amp;= - mathbf{t^T} log mathbf{y} end{aligned}LCE​(y,t)​=−k=1∑K​tk​logyk​=−tTlogy​ . Combining these things together, we get multiclass logistic regression: . z=wx+by=softmax(z)LCE(y,t)=−tTlog⁡y begin{aligned} mathbf{z} &amp;= mathbf{wx + b} mathbf{y} &amp;= softmax( mathbf{z}) mathcal{L}_{CE}(y,t) &amp;=- mathbf{t^T} log mathbf{y} end{aligned}zyLCE​(y,t)​=wx+b=softmax(z)=−tTlogy​ . Gradient Descent for Multiclass Logistic Regression for Multiclass logistic regression: . Let consider the derivative with respect to the loss: . ∂LCE∂wkj=∂∂wkj(−∑ltllog⁡(yl))=−∑ltlyl∂yl∂wkj begin{aligned} frac{ partial { mathcal L}_ text{CE}}{ partial w_{kj}} &amp;= frac{ partial }{ partial w_{kj}} left(- sum_l t_l log(y_l) right) &amp;= - sum_l frac{t_l}{y_l} frac{ partial y_l}{ partial w_{kj}} end{aligned}∂wkj​∂LCE​​​=∂wkj​∂​(−l∑​tl​log(yl​))=−l∑​yl​tl​​∂wkj​∂yl​​​ . Normally in calculus we have the rule: . ∂yl∂wkj=∑m∂yl∂zm∂zm∂wkj begin{aligned} frac{ partial y_l}{ partial w_{kj}} &amp;= sum_m frac{ partial y_l}{ partial z_m} frac{ partial z_m}{ partial w_{kj}} end{aligned}∂wkj​∂yl​​​=m∑​∂zm​∂yl​​∂wkj​∂zm​​​ . But wkjw_{kj}wkj​ is independent of zmz_mzm​ for m≠km ne km​=k, so . ∂yl∂wkj=∂yl∂zk∂zk∂wkj begin{aligned} frac{ partial y_l}{ partial w_{kj}} &amp;= frac{ partial y_l}{ partial z_k} frac{ partial z_k}{ partial w_{kj}} end{aligned}∂wkj​∂yl​​​=∂zk​∂yl​​∂wkj​∂zk​​​ . AND . ∂zk∂wkj=xj frac{ partial z_k}{ partial w_{kj}} = x_j∂wkj​∂zk​​=xj​ . Thus . ∂LCE∂wkj=−∑ltlyl∂yl∂zk∂zk∂wkj=−∑ltlyl∂yl∂zkxj=xj(−∑ltlyl∂yl∂zk)=xj∂LCE∂zk begin{aligned} frac{ partial { mathcal L}_ text{CE}}{ partial w_{kj}} &amp;= - sum_l frac{t_l}{y_l} frac{ partial y_l}{ partial z_k} frac{ partial z_k}{ partial w_{kj}} &amp;= - sum_l frac{t_l}{y_l} frac{ partial y_l}{ partial z_k} x_j &amp;= x_j (- sum_l frac{t_l}{y_l} frac{ partial y_l}{ partial z_k}) &amp;= x_j frac{ partial { mathcal L}_ text{CE}}{ partial z_k} end{aligned}∂wkj​∂LCE​​​=−l∑​yl​tl​​∂zk​∂yl​​∂wkj​∂zk​​=−l∑​yl​tl​​∂zk​∂yl​​xj​=xj​(−l∑​yl​tl​​∂zk​∂yl​​)=xj​∂zk​∂LCE​​​ . Now consider derivative with respect to $z_k$ we can show (onboard) that. . ∂yl∂zk=yk(Ik,l−yl) frac{ partial y_l}{ partial z_k} = y_k (I_{k,l} - y_l)∂zk​∂yl​​=yk​(Ik,l​−yl​) . Where $I_{k,l} = 1$ if $k=l$ and $0$ otherwise. . Therefore . ∂LCE∂zk=−∑ltlyl(yk(Ik,l−yl))=−tkykyk(1−yk)−∑l≠ktlyl(−ykyl)=−tk(1−yk)+∑l≠ktlyk=−tk+tkyk+∑l≠ktlyk=−tk+∑ltlyk=−tk+yk∑ltl=−tk+yk=yk−tk begin{aligned} frac{ partial { mathcal L}_ text{CE}}{ partial z_k} &amp;= - sum_l frac{t_l}{y_l} (y_k (I_{k,l} - y_l)) &amp;=- frac{t_k}{y_k} y_k(1 - y_k) - sum_{l ne k} frac{t_l}{y_l} (-y_k y_l) &amp;= - t_k(1 - y_k) + sum_{l ne k} t_l y_k &amp;= -t_k + t_k y_k + sum_{l ne k} t_l y_k &amp;= -t_k + sum_{l} t_l y_k &amp;= -t_k + y_k sum_{l} t_l &amp;= -t_k + y_k &amp;= y_k - t_k end{aligned}∂zk​∂LCE​​​=−l∑​yl​tl​​(yk​(Ik,l​−yl​))=−yk​tk​​yk​(1−yk​)−l​=k∑​yl​tl​​(−yk​yl​)=−tk​(1−yk​)+l​=k∑​tl​yk​=−tk​+tk​yk​+l​=k∑​tl​yk​=−tk​+l∑​tl​yk​=−tk​+yk​l∑​tl​=−tk​+yk​=yk​−tk​​ . Putting it all together . ∂LCE∂wkj=xj(yk−tk) begin{aligned} frac{ partial { mathcal L}_ text{CE}}{ partial w_{kj}} &amp;= x_j (y_k - t_k) end{aligned}∂wkj​∂LCE​​​=xj​(yk​−tk​)​ . In vectorization form it become: . ∂LCE∂W=(y−t)xT begin{aligned} frac{ partial mathcal {L}_{CE}}{ partial { mathbf W}} = ( mathbf{y} - mathbf{t}) mathbf{x}^T end{aligned}∂W∂LCE​​=(y−t)xT​ . Cross-entropy cost function . The cross entropy cost function for multiclass classification is given with respect to the model parameters θ thetaθ (i.e. the weights and bias) is therefore: . εθ=1N∑i=1NLCE(y,t)=−1N∑i=1N∑k=1Ktklog⁡yk begin{aligned} varepsilon_{ theta} &amp; = frac{1}{N} sum_{i=1}^N mathcal{L}_{CE}(y,t) &amp; = frac{-1}{N} sum_{i=1}^N sum_{k=1}^K t_k log y_k end{aligned}εθ​​=N1​i=1∑N​LCE​(y,t)=N−1​i=1∑N​k=1∑K​tk​logyk​​ . The gradient descent algorithm will be: wk+1=wk−α∂ε∂w mathbf{w_{k+1}} = mathbf{ w_k }- alpha frac{ partial mathbf{ varepsilon}}{ partial mathbf{w}}wk+1​=wk​−α∂w∂ε​ . where: . ∂LCE∂ε=∂ε∂LCE⋅∂LCE∂w=1NxT(y−t) begin{aligned} frac{ partial mathcal{L}_{CE}}{ partial varepsilon} &amp;= frac{ partial varepsilon }{ partial mathcal{L}_{CE}} cdot frac{ partial mathcal{L}_{CE}}{ partial mathbf{w}} &amp;= frac{1}{N} mathbf{x^T(y - t)} end{aligned}∂ε∂LCE​​​=∂LCE​∂ε​⋅∂w∂LCE​​=N1​xT(y−t)​ . References . CSC321 Intro to Neural Networks and Machine Learning | Supervised and Unsupervised Machine Learning Algorithms | .",
            "url": "https://sambaiga.github.io/sambaiga/machine%20learning/2017/07/02/ml-classification.html",
            "relUrl": "/machine%20learning/2017/07/02/ml-classification.html",
            "date": " • Jul 2, 2017"
        }
        
    
  
    
        ,"post12": {
            "title": "Learning HMM parameters for Continous Density Models",
            "content": "Introduction . In the previous post, we considered a scenario where observation sequences YYY are discrete symbols. However, for many practical problems, the observation symbols are continuous vectors. As a result, the continuous probability density function (pdf) is used to model the space of the observation signal associated with each state. The most commonly used emission distribution is gaussian distribution and the gaussian mixture models. . Gaussian Distribution and the Gaussian Mixture Models . It is popular to represent the randomness of continuous-valued using the multivariate Gaussian distribution. A vector-valued random variable x mathbf{x}x is said to have a multivariate normal (or Gaussian) distribution with mean μ=E[x] mu= mathop{ mathbf{E[x]}}μ=E[x] and covariance matrix Σ=cov[x] Sigma= mathbf{cov[x]}Σ=cov[x] if: P(x;μ,Σ)=N(x∣μ,Σ)=1(2π)D/2∣Σ∣12exp⁡(−12[x−μ]Σ−1[x−μ]T)P( mathbf{x}; mu, Sigma) = mathcal{N( mathbf{x} mid mu, Sigma)}= frac{1}{(2 pi)^{D/2} | Sigma|^ frac{1}{2}} quad exp Big(- frac{1}{2}[ mathbf{x} - mu] Sigma^{-1}[ mathbf{x} - mu]^ mathsf{T} Big)P(x;μ,Σ)=N(x∣μ,Σ)=(2π)D/2∣Σ∣21​1​exp(−21​[x−μ]Σ−1[x−μ]T) where DDD is the dimensionality of x mathbf{x}x. The μ muμ represents the location where samples are most likely to be generated, and the Σ SigmaΣ indicates the level to which two variables vary together. . However, a single Gaussian distribution is insufficient to represent the state-dependent observation space for an HMM state st=is_t=ist​=i. This is because there are large amounts of training data collected from various appliance instances with different modes, distortions, background noises, etc which are used to train the parameters of individual HMM states. In this case, a Gaussian mixture model (GMM) is adopted to represent the state-dependent observation space. . A mixture model is a probabilistic model for density estimation using a mixture distribution and can be regarded as a type of unsupervised learning or clustering. They provide a method of describing more complex probability distributions by combining several probability distributions. The following equation gives a multivariate Gaussian mixture distribution: P(x)=∑k=1KωkN(x∣μk,Σk)P( mathbf{x}) = displaystyle sum_{k=1}^{K} omega_k mathcal{N( mathbf{x} mid mu_k, Sigma_k)}P(x)=k=1∑K​ωk​N(x∣μk​,Σk​) The parameters ωk omega_kωk​ are called mixing coefficients, which must fulfill ∑k=1Kωk=1 displaystyle sum_{k=1}^{K} omega_k =1k=1∑K​ωk​=1 and given N(x∣μk,Σk)≥0 mathcal{N( mathbf{x} mid mu_k, Sigma_k)} geq 0N(x∣μk​,Σk​)≥0 and P(x)≥0P( mathbf{x}) geq 0P(x)≥0 we also have that 0≤ωk≥10 leq omega_k geq 10≤ωk​≥1. Each Gaussian density N(x∣μk,Σk) mathcal{N( mathbf{x} mid mu_k, Sigma_k)}N(x∣μk​,Σk​) is called a component of the mixture and has its own mean μk mu_kμk​ and covariance Σk Sigma_kΣk​. . HMM with Gaussian emission distribution . If the observations are continuous, it is common for the emission probabilities to be a conditional Gaussian such that: P(yt∣st=i)=N(yt∣μi,Σi)P( mathbb{y_t} mid s_t =i) = mathcal{N( mathbf{y_t} mid mu_i, Sigma_i)}P(yt​∣st​=i)=N(yt​∣μi​,Σi​) where μi mu_iμi​ and Σi Sigma_iΣi​ are mean vector and covariance matrix associated with state iii. The re-estimation formula for the mean vector and covariance matrix of a state gausian pdf can be derived as: μ^i=∑t=1Tγt(i)y(t)∑t=1Tγt(i)Σ^i=∑t=1Tγt(i)[y(t)−μ^i]⋅[y(t)−μ^i]T∑t=1Tγt(i) begin{aligned} hat{ mu}_i &amp; = frac{ displaystyle sum_{t=1}^{T} gamma_t(i) mathbb{y(t)}}{ displaystyle sum_{t=1}^{T} gamma _t(i)} hat{ Sigma}_i &amp; = frac{ displaystyle sum_{t=1}^{T} gamma_t(i) [ mathbf{y(t)}- hat{ mu}_i] cdot[ mathbf{y(t)}- hat{ mu}_i]^T}{ displaystyle sum_{t=1}^{T} gamma_t(i)} end{aligned}μ^​i​Σ^i​​=t=1∑T​γt​(i)t=1∑T​γt​(i)y(t)​=t=1∑T​γt​(i)t=1∑T​γt​(i)[y(t)−μ^​i​]⋅[y(t)−μ^​i​]T​​ . HMMs with Gaussian Mixture Model . In HMMs with Gaussian mixture pdf, the emission probabilities is given by P(yt∣st=i)=∑k=1Mω_ikN(yt∣μik,Σik)P( mathbb{y_t} mid s_t =i) = displaystyle sum_{k=1}^{M} omega _{ik} mathcal{N( mathbb{y_t} mid mu_{ik}, Sigma_{ik})}P(yt​∣st​=i)=k=1∑M​ω_ikN(yt​∣μik​,Σik​) where ωik omega_{ik}ωik​ is the prior probability of the kthk^{th}kth component of the mixture. The posterior probability of state st=is_t=ist​=i at time ttt and state st+1=js_{t+1}=jst+1​=j at time t+1t+1t+1 given the model λ lambdaλ and the observation sequence YYY is γt(i,j)=P(st=i,st+1=j∣Y,λ)=αt(i)aij[∑k=1MωikN(yt∣μik,Σik)]βt+1(j)∑i=1NαT(i) begin{aligned} gamma_t(i,j)&amp; =P(s_t=i, s_{t+1}=j mid Y, lambda) &amp; = frac{ alpha_t(i)a_{ij} Big[ displaystyle sum_{k=1}^{M} omega_{ik} mathcal{N( mathbf{y_t} mid mu_{ik}, Sigma_{ik})} Big] beta_{t+1}(j)}{ displaystyle sum_{i=1}^{N} alpha_T(i)} end{aligned}γt​(i,j)​=P(st​=i,st+1​=j∣Y,λ)=i=1∑N​αT​(i)αt​(i)aij​[k=1∑M​ωik​N(yt​∣μik​,Σik​)]βt+1​(j)​​ . and the posterior probability of state st=is_t=ist​=i at time ttt given the model λ lambdaλ and observation YYY is γt(i)=αt(i)βt(i)∑i=1NαT(i) gamma_t(i) = frac{ alpha_t(i) beta_t(i)}{ displaystyle sum_{i=1}^{N} alpha _T(i)}γt​(i)=i=1∑N​αT​(i)αt​(i)βt​(i)​ Let define the joint posterior probability of the state sis_isi​ and the kthk^{th}kth gaussian component pdf of state iii at time ttt . ξ(i,k)=P(St=si,m(t)=k∣Y,λ)=∑j=1Nαt(j)aijωikN(yt∣μik,Σik)βt+1(j)∑i=1NαT(i) begin{aligned} xi(i,k) &amp;= P(S_t=s_i, m(t)=k mid Y, lambda) &amp;= frac{ displaystyle sum_{j=1}^{N} alpha_t(j) a_{ij} omega_{ik} mathcal{N( mathbf{y_t} mid mu_{ik}, Sigma_{ik})} beta_{t+1}(j)}{ displaystyle sum_{i=1}^{N} alpha _T(i)} end{aligned}ξ(i,k)​=P(St​=si​,m(t)=k∣Y,λ)=i=1∑N​αT​(i)j=1∑N​αt​(j)aij​ωik​N(yt​∣μik​,Σik​)βt+1​(j)​​ . The re-estimation formula for the mixture coefficients, the mean vectors and the covariance matrices of the state mixture gaussian pdf as . ω^ik=∑t=1Tξt(i,k)∑_t=0Tγt(i)μ^ik=∑ t=1Tξ t(i,k)yt∑t=1Tξt(i,k)Σ^ik=∑t=1Tξt(i,k)[yt−μ^ik]⋅[yt−μ^ik]T∑t=1Tξt(i,k) begin{aligned} hat{ omega}_{ik} &amp;= frac{ displaystyle sum_{t=1}^{T} xi_t(i,k)}{ displaystyle sum _{t=0}^{T} gamma_t(i)} hat{ mu}_{ik} &amp;= frac{ displaystyle sum _{t=1}^{T} xi _t(i,k) mathbf{y_t}}{ displaystyle sum_{t=1}^{T} xi_t(i,k)} hat{ Sigma}_{ik}&amp;= frac{ displaystyle sum_{t=1}^{T} xi_t(i,k)[ mathbf{y_t}- hat{ mu}_{ik}] cdot[ mathbf{y_t}- hat{ mu}_{ik}]^T}{ displaystyle sum_{t=1}^{T} xi_t(i,k)} end{aligned}ω^ik​μ^​ik​Σ^ik​​=∑_t=0Tγt​(i)t=1∑T​ξt​(i,k)​=t=1∑T​ξt​(i,k)∑ t=1T​ξ t​(i,k)yt​​=t=1∑T​ξt​(i,k)t=1∑T​ξt​(i,k)[yt​−μ^​ik​]⋅[yt​−μ^​ik​]T​​ . Limitation of Baum–Welch algorithm . When applying the Baum–Welch algorithm in real data, we need to consider some heuristics in the ML EM algorithm. . How to provide initial parameter values. This is always an important question, and it is usually resolved by using a simple algorithm (e.g., K-means clustering or random initialization). | How to avoid instability in the parameter estimation (especially covariance parameter estimation) due to data sparseness. For example, some mixture components or hidden states cannot have sufficient data assigned in the Viterbi or forward-backward algorithm. This can be heuristically avoided by setting a threshold to update these parameters or setting minimum threshold values for covariance parameters. | Bayesian approaches can solve the above two problems. . References . Saeed V. Vaseghi, Advanced Digital Signal Processing, and Noise Reduction. John Wiley &amp; Sons, 2008. | Kevin P. Murphy, Machine Learning: A Probabilistic Perspective. The MIT Press Cambridge, Massachusetts, 2012. |",
            "url": "https://sambaiga.github.io/sambaiga/machine%20learning/2017/06/06/hmm-gausian.html",
            "relUrl": "/machine%20learning/2017/06/06/hmm-gausian.html",
            "date": " • Jun 6, 2017"
        }
        
    
  
    
        ,"post13": {
            "title": "Introduction to Machine Learning",
            "content": "Introduction . Machine learning is a set of algorithms that automatically detect patterns in data and use the uncovered pattern to make inferences or predictions. It is a subfield of artificial intelligence that aims to enable computers to learn on their own. Any machine learning algorithms involve the necessary three steps: first, you identify a pattern from data, build (train) model that best explains the pattern and the world (unseen data), and lastly, use the model to predict or make an inference. Model training (building) can be seen as a learning process where the model is exposed to new, unfamiliar data step by step. . Machine learning is an exciting and fast-moving field of computer science with many new applications. Applications where machine learning algorithms are regularly deployed includes: . Computer vision: Object Classification in Photograph, image captioning. | Speech recognition, Automatic Machine Translation. | Detecting anomalies (e.g. Security, credit card fraud) | Speech recognition. | Communication systemsref | Robots learning complex behaviors | Recommendations services like in Amazo or Netflix where intelligent machine learning algorithms analyze your activity and compare it to the millions of other users to determine what you might like to buy or binge watch nextref. | . Machine learning algorithms that learn to recognize what they see have been the heart of Apple, Google, Amazon, Facebook, Netflix, Microsoft, etc. . Why Machine learning . For many problems such as recognizing people and objects and understanding human speech, it’s difficult to program the correct behavior by hand. However, with machine learning, these tasks are easier. Other reasons we might want to use machine learning to solve a given problem: . A system might need to adapt to a changing environment. For instance, spammers are always trying to figure out ways to trick our e-mail spam classifiers, so the classification algorithms will need to adapt continually. | A learning algorithm might be able to perform better than its human programmers. Learning algorithms have become world champions at a variety of games, from checkers to chess to Go. This would be impossible if the programs were only doing what they were explicitly told to do. | We may want an algorithm to behave autonomously for privacy or fairness reasons, such as with ranking search results or targeting ads. | . Types of Machine Learning . Machine learning is usually divided into three major types: Supervised Learning, Unsupervised Learning and . Supervised Learning: Supervised learning is where you have input variables x and an output variable y, and use an algorithm to learn the mapping function from the input to the outputref. For instance, if we’re trying to train a machine-learning algorithm to distinguish cars and trucks, we would collect car and truck images and label each one as a car or a truck. Supervised learning problems can be further grouped into regression and classification problems. . A regression problem: is when the output variable is a real value, such as “dollars” or “weight” e.g Linear regression and Random forest. | Classification: A classification problem is when the output variable is a category, such as “red” or “blue” or “disease” and “no disease”, e.g. Support vector machines, random forest, and logistic regression. Some famous examples of supervised machine learning algorithms are: | . Unsupervised Learning : Unsupervised learning is where you only have input data (X) and no corresponding output variables. We just have a bunch of data and want to look for patterns in the data. For instance, maybe we have lots of examples of patients with autism and want to identify different subtypes of the condition. The most important types of unsupervised learning include: . Distribution modeling where one has an unlabeled dataset (such as a collection of images or sentences), and the goal is to learn a probability distribution that matches the dataset as closely as possible. | Clustering where the aim is to discover the inherent groupings in the data, such as grouping customers by purchasing behavior. | . Reinforcement Learning: is learning best actions based on reward or punishment. It involves learning what actions to take in a given situation, based on rewards and penalties. For example, a robot takes a big step forward, then falls. The next time, it takes a smaller stage and is able to hold its balance. The robot tries variations like this many times; eventually, it learns the right size of steps to take and walks steadily. It has succeeded. . There are three basic concepts in reinforcement learning: state, action, and reward. The state describes the current situation. Action is what an agent can do in each state. When a robot takes action in a state, it receives a reward, feedback from the environment. A reward can be positive or negative (penalties). . Typical ML task: Linear Regression . In regression, we are interested in predicting a scalar-valued target, such as the price of a stock. By linear, we mean that the target must be predicted as a linear function of the inputs. This is a kind of supervised learning algorithm; recall that, in supervised learning, we have a collection of training examples labeled with the correct outputs. Example applications of linear regression include weather forecasting, house pricing prediction, student performance (GPA) prediction, just to mention a few. . Linear Regression: Formulating a learning problem . To formulate a learning problem mathematically, we need to define two things: a model (hypothesis)** and a *loss function. After defining model and loss function, we solve an optimization problem with the aim to find the model parameters that best fit the data. . Model (Hypothesis): It is the set of allowable hypotheses or functions that compute predictions from the inputs. In the case of linear regression, the model simply consists of linear functions given by: . y=∑jwjxj+by = sum_j w_jx_j + by=j∑​wj​xj​+b . where www is the weights, and bbb is an intercept term, which we’ll call the bias. These two terms are called model parameters denoted as θ thetaθ. . Loss function: It defines how well the model fit the data and thus show how far off the prediction yyy is from the target ttt and given as: . L(y,t)=12(y−t)2 mathcal{L(y,t)} = frac{1}{2}(y - t)^2L(y,t)=21​(y−t)2 . Since the loss function show how far off the prediction is from the target for one data point. We also need to define a cost function. The cost function is simply the loss, averaged over all the training examples. . J(w1…wD,b)=1N∑i=1NL(y(i),t(i))=12N∑i=1N(y(i)−t(i))2=12N∑i=1N(∑jwjxj(i)+b−t(i)) begin{aligned} J (w_1 ldots w_D,b) &amp; = frac{1}{N} sum_{i=1}^N mathcal{L}(y^{(i)},t^{(i)}) &amp; = frac{1}{2N} sum_{i=1}^N (y^{(i)} - t^{(i)})^2 &amp;= frac{1}{2N} sum_{i=1}^N left( sum_j w_jx_j^{(i)} + b -t^{(i)} right) end{aligned}J(w1​…wD​,b)​=N1​i=1∑N​L(y(i),t(i))=2N1​i=1∑N​(y(i)−t(i))2=2N1​i=1∑N​(j∑​wj​xj(i)​+b−t(i))​ . In vectorized form: . J=12N∥y−t∥2=12N(y−t)T(y−t)wherey=wTx mathbf{J} = frac{1}{2N} lVert mathbf{y-t} lVert^2 = frac{1}{2N} mathbf{(y - t)^T(y-t)} quad text{where} quad mathbf{y = w^Tx}J=2N1​∥y−t∥2=2N1​(y−t)T(y−t)wherey=wTx . The python implementation of the cost function (vectorized) is shown below. . def loss(x, w, t): N, D = np.shape(x) y = np.matmul(x,w.T) loss = (y - t) return loss . def cost(x,w, t): &#39;&#39;&#39; Evaluate the cost function in a vectorized manner for inputs `x` and targets `t`, at weights `w1`, `w2` and `b`. N, D = np.shape(x) return (loss(x, w,t) **2).sum() / (2.0 * N) . Combine our model and loss function, we get an optimization problem, where we are trying to minimize a cost function concerning the model parameters θ thetaθ (i.e. the weights and bias). . Solving the optimization problem . We now want to find the choice of model parameters θw1…wD,b theta _{w_1 ldots w_D,b}θw1​…wD​,b​ that minimizes J(w1…wD,b)J (w_1 ldots w_D,b)J(w1​…wD​,b) as given in the cost function above.There are two methods that we can use: direct solution and gradient descent. . Direct Solution . One way to compute the minimum of a function is to set the partial derivatives to zero. For simplicity, let’s assume the model doesn’t have a bias term, as shown in the equation below. . Jθ=12N∑i=1N(∑jwjxj(i)−t(i))J_ theta = frac{1}{2N} sum_{i=1}^N left( sum_j w_jx_j^{(i)} -t^{(i)} right)Jθ​=2N1​i=1∑N​(j∑​wj​xj(i)​−t(i)) . In vectorized form . J=12N∥y−t∥212N(y−t)T(y−t)wherey=wx mathbf{J} = frac{1}{2N} lVert mathbf{y-t} rVert ^2 frac{1}{2N} mathbf{(y - t)^T(y-t)} quad text{where} quad mathbf{y = wx}J=2N1​∥y−t∥22N1​(y−t)T(y−t)wherey=wx . For matrix differentiation we need the following results: . ∂Ax∂x=AT∂(xTAx)∂x=2ATx begin{aligned} frac{ partial mathbf{Ax}}{ partial mathbf{x}} &amp; = mathbf{A}^T frac{ partial ( mathbf{x}^T mathbf{Ax})}{ partial mathbf{x}} &amp; = 2 mathbf{A}^T mathbf{x} end{aligned}∂x∂Ax​​=AT∂x∂(xTAx)​=2ATx​ . Setting the partial derivatives of cost function in vectorized form to zero we obtain: . ∂J∂w=12N∂(wTxTxw−2tTwx+tTt)∂w=12N(2xTxw−2xTt)w=(xTx)−1xTt begin{aligned} frac{ partial mathbf{J}}{ partial mathbf{w}} &amp; = frac{1}{2N} frac{ partial left( mathbf{w^Tx^Tx w} -2 mathbf{t^Twx} + mathbf{t^Tt} right)}{ partial mathbf{w}} &amp;= frac{1}{2N} left(2 mathbf{x}^T mathbf{xw} -2 mathbf{x}^T mathbf{t} right) mathbf{w} &amp;= ( mathbf{x^Tx})^{-1} mathbf{x^Tt} end{aligned}∂w∂J​w​=2N1​∂w∂(wTxTxw−2tTwx+tTt)​=2N1​(2xTxw−2xTt)=(xTx)−1xTt​ . In python, this result can be implemented as follows: . def direct method(x, t): &#39;&#39;&#39; Solve linear regression exactly. (fully vectorized) Given `x` - NxD matrix of inputs `t` - target outputs Returns the optimal weights as a D-dimensional vector &#39;&#39;&#39; N, D = np.shape(x) A = np.matmul(x.T, x) c = np.dot(x.T, t) return np.matmul(linalg.inv(A), c) . Gradient Descent . The optimization algorithm commonly used to train machine learning is the gradient descent algorithm. It works by taking the derivative of the cost function JJJ with respect to the parameters at a specific position on this cost function and updates the parameters in the direction of the negative gradient. The entries of the gradient vector are simply the partial derivatives with respect to each of the variables: . ∂J∂w=(∂J∂w1⋮∂J∂wD) frac{ partial mathbf{J}}{ partial mathbf{w}} = begin{pmatrix} frac{ partial J}{ partial w_1} vdots frac{ partial J}{ partial w_D} end{pmatrix}∂w∂J​=⎝⎜⎜⎛​∂w1​∂J​⋮∂wD​∂J​​⎠⎟⎟⎞​ . The parameter w mathbf{w}w is iteratively updated by taking steps proportional to the negative of the gradient: . wt+1=wt−α∂J∂w=wt−αNxT(y−t) mathbf{w_{t+1}} = mathbf{ w_t }- alpha frac{ partial mathbf{J}}{ partial mathbf{w}} = mathbf{w_t} - mathbf{ frac{ alpha}{N}x^T(y-t)}wt+1​=wt​−α∂w∂J​=wt​−Nα​xT(y−t) . In coordinate systems this is equivalent to: . wt+1=wt−α1N∑i=1Nxt(y(i)−t(i))w_{t+1} = w_t - alpha frac{1}{N} sum_{i=1}^{N} x_t (y^{(i)}-t^{(i)})wt+1​=wt​−αN1​i=1∑N​xt​(y(i)−t(i)) . The python implementation of gradient descent is shown below: . def getGradient(x, w, t): N, D = np.shape(x) gradient = (1.0/ float(N)) * np.matmul(np.transpose(x), loss(x,w,t)) return gradient . def gradientDescentMethod(x, t, alpha=0.1, tolerance=1e-2): N, D = np.shape(x) #w = np.random.randn(D) w = np.zeros([D]) # Perform Gradient Descent iterations = 1 w_cost = [(w, cost(x,w, t))] while True: dw = getGradient(x, w, t) w_k = w - alpha * dw w_cost.append((w, cost(x, w, t))) # Stopping Condition if np.sum(abs(w_k - w)) &lt; tolerance: print (&quot;Converged.&quot;) break if iterations % 100 == 0: print (&quot;Iteration: %d - cost: %.4f&quot; %(iterations, cost(x, w, t))) iterations += 1 w = w_k return w, w_cost . Generalization . The goal of a learning algorithm is not only to make correct predictions on the training examples but also to be generalized to patterns not seen before. The average squared error on new examples is known as the generalization error, and we’d like this to be as small as possible. In practice, we normally tune model parameters by partitioning the dataset into three different subsets: . The training set is used to train the model. | The validation set is used to estimate the generalization error of each hyperparameter setting. | The test set is used at the very end, to estimate the generalization error of the final model, once all hyperparameters have been chosen. | .",
            "url": "https://sambaiga.github.io/sambaiga/machine%20learning/2017/06/01/ml-introduction.html",
            "relUrl": "/machine%20learning/2017/06/01/ml-introduction.html",
            "date": " • Jun 1, 2017"
        }
        
    
  
    
        ,"post14": {
            "title": "Learning HMM parameters with Discrete Observation Models",
            "content": "Introduction . In the previous post, we discussed the basics of HMM modeling given model parameters λ lambdaλ and compute the likelihood values etc., efficiently based on the forward, backward, and Viterbi algorithms. In the like manner, we can efficiently train the HMM to obtain the model parameter λ^ hat{ lambda}λ^ from data. In this post, we will discuss different methods for training HMM models. . This is the solution to Problem 3, which involves determining a method to learn model parameters λ^ hat{ lambda}λ^ given the sequence of observation variables YYY. Given the observation sequences YYY as training data, there is no optimal way of estimating the model parameters. However, using iterative procedure we can choose λ^=(A^,B^,π^) hat{ lambda} = ( hat{A}, hat{B}, hat{ pi})λ^=(A^,B^,π^) such that P(Y∣λ)P(Y mid lambda)P(Y∣λ) is locally maximized.The most common procedure which has been employed to his problem is the Baum-Welch method. . Baum-Welch Methods . This method assumes an initial model parameter of λ lambdaλ, which should be adjusted to increase P(Y∣λ)P(Y mid lambda)P(Y∣λ). The initial parametrs can be constructed in any way or employ the first five procedure of the Segmental K-means algorithm. The optimazation criteria is called the maximum likelihood criteria.The function P(Y∣λ)P(Y mid lambda)P(Y∣λ) is called the likelihood function. . The E-M Auxilliary Function . Let λ lambdaλ represent the current model and λ^ hat{ lambda}λ^ represent the candidate models. The learning objective is to make: P(Y∣λ^)≥P(Y∣λ)P(Y mid hat{ lambda}) geq P(Y mid lambda)P(Y∣λ^)≥P(Y∣λ) which is equivalently to log⁡[P(Y∣λ^)]≥log⁡[P(Y∣λ)] log[P(Y mid hat{ lambda})] geq log [P(Y mid lambda)]log[P(Y∣λ^)]≥log[P(Y∣λ)] . Let also define the auxilliary function Q(λ^∣λ)Q( hat{ lambda} mid lambda)Q(λ^∣λ) such that: Q(λ^∣λ)=E[log⁡P(Y,S∣λ^)∣Y,λ]=∑sP(S∣Y,λ)⋅log⁡[P(Y,S∣λ^)] begin{aligned} Q( hat{ lambda} mid lambda) &amp; = mathbb{E} Big[ log P(Y,S mid hat{ lambda}) mid Y, lambda Big] &amp; = sum_s P(S mid Y, lambda) cdot log [P(Y,S mid hat{ lambda})] end{aligned}Q(λ^∣λ)​=E[logP(Y,S∣λ^)∣Y,λ]=s∑​P(S∣Y,λ)⋅log[P(Y,S∣λ^)]​ . The Maximum Likelihood Estimation (MLE) of the model parameter λ lambdaλ for complete data YYY and hidden state SSS is; . λ^=arg⁡max⁡λ∑sP(Y,S∣λ) hat{ lambda} = arg max _{ lambda} sum_s P(Y, S mid lambda)λ^=argλmax​s∑​P(Y,S∣λ) . However due to the presence of several stochatsic constraints it turns out to be easier to mximize uxilliary function Q(λ^∣λ)Q( hat{ lambda} mid lambda)Q(λ^∣λ) rather than directly maximize P(Y∣λ^)P(Y mid hat{ lambda})P(Y∣λ^). Thus the MLE of the model parameter λ lambdaλ for complete data YYY and hidden state SSS become: . λ^=arg⁡max⁡λQ(λ^∣λ) hat{ lambda} = arg max _{ lambda} Q( hat{ lambda} mid lambda)λ^=argλmax​Q(λ^∣λ) . It can be shown that the parameter estimated by the EM procedure, Q(λ^∣λ)Q( hat{ lambda} mid lambda)Q(λ^∣λ), always increases the likelihood value. You may concert reference 2 chapter 3 for details on the prove. . Expectation step . To find ML estimates of HMM parameters, we first expand the auxiliary function rewrite it by substituting the joint distribution of complete data likelihood. . Q(λ^∣λ)=E[log⁡P(Y,S∣λ^)∣Y,λ]=∑sP(S∣Y,λ)⋅log⁡[P(Y,S∣λ^)]=∑sP(S∣Y,λ)⋅[log⁡π^1+log⁡b^1(y1)+∑t=2T(log⁡a^ij+log⁡b^i(yt))] begin{aligned} Q( hat{ lambda} mid lambda) &amp; = mathbf{E} Big[ log P(Y,S mid hat{ lambda}) mid Y, lambda Big] &amp; = sum_s P(S mid Y, lambda) cdot log [P(Y,S mid hat{ lambda})] &amp; = sum_s P(S mid Y, lambda) cdot Big[ log hat{ pi}_1 + log hat{b}_1(y_1) + sum _{t=2}^T big( log hat{a} _{ij} + log hat{b}_i({y_t}) big) Big] end{aligned}Q(λ^∣λ)​=E[logP(Y,S∣λ^)∣Y,λ]=s∑​P(S∣Y,λ)⋅log[P(Y,S∣λ^)]=s∑​P(S∣Y,λ)⋅[logπ^1​+logb^1​(y1​)+t=2∑T​(loga^ij​+logb^i​(yt​))]​ . We have three term to solve: . The initial probability π^ hat{ pi}π^ , | State transition probability A^=a^ij hat{A} = hat{a}_{ij}A^=a^ij​ and | Emission probability B^=b^i(yt) hat{B} = hat{b}_i(y_t)B^=b^i​(yt​). | . Let first define important parameters that we will use. For t=1,2...Tt = 1,2...Tt=1,2...T, 1≤i≥N1 leq i geq N1≤i≥N and 1≤j≥N1 leq j geq N1≤j≥N, we define: . ξt(i,j)=P(st=i,st+1=j∣Y,λ) xi_t(i,j)=P(s_t=i, s_{t+1}=j mid Y, lambda)ξt​(i,j)=P(st​=i,st+1​=j∣Y,λ) . an expected transition probability from st=is_t=ist​=i to , st+1=js_{t+1}=jst+1​=j. The probability of being in state sis_isi​ at time ttt and state sjs_jsj​ at time t+1t+1t+1 given the model λ lambdaλ and observation sequences YYY. . ξt(i,j) xi_t(i,j)ξt​(i,j) can be written in terms of forward αt(i) alpha_t(i)αt​(i) and backward βt+1(j) beta_{t+1}(j)βt+1​(j) variables as: . ξt(i,j)=αt(i)aijbi(yt+1)βt+1(j)P(Y∣λ)=αt(i)aijbi(yt+1)βt+1(i)∑i=1N∑j=1Nαt(i)aijbj(yt+1)βt+1(j) begin{aligned} xi_t(i,j) &amp;= frac{ alpha_t(i)a_{ij}b_i(y_{t+1}) beta_{t+1}(j)}{P(Y mid lambda)} &amp;= frac{ alpha_t(i)a_{ij}b_i(y_{t+1}) beta_{t+1}(i)}{ displaystyle sum_{i=1}^{N} displaystyle sum_{j=1}^{N} alpha_t(i)a_{ij}b_j(y_{t+1}) beta_{t+1}(j)} end{aligned}ξt​(i,j)​=P(Y∣λ)αt​(i)aij​bi​(yt+1​)βt+1​(j)​=i=1∑N​j=1∑N​αt​(i)aij​bj​(yt+1​)βt+1​(j)αt​(i)aij​bi​(yt+1​)βt+1​(i)​​ . where the numerator term is just P(St=si,St+1=sj∣Y,λ)P(S_t=s_i, S_{t+1}=s_j mid Y, lambda)P(St​=si​,St+1​=sj​∣Y,λ) and the division by P(Y∣λ)P(Y mid lambda)P(Y∣λ) gives the desire probability measures. . We have previosly difined γt(i)=αt(i)βt(i)P(Y∣λ) gamma_t(i) = frac{ alpha_t(i) beta_t(i)}{P(Y mid lambda)}γt​(i)=P(Y∣λ)αt​(i)βt​(i)​ as the probability of being in state sis_isi​ at time ttt given the observation sequence and model parameter. γt(i) gamma_t(i)γt​(i) relate to ξt(i,j) xi_t(i,j)ξt​(i,j) as follows: . γt(i)=∑j=1Nξt(i,j) gamma_t(i) = displaystyle sum_{j=1}^{N} xi_t(i,j)γt​(i)=j=1∑N​ξt​(i,j) . It follows that: . ∑t=1T−1γt(i)= displaystyle sum_{t=1}^{T-1} gamma_t(i)=t=1∑T−1​γt​(i)= Expected number of transitions from state iii . . ∑t=1T−1ξt(i,j)= displaystyle sum_{t=1}^{T-1} xi_t(i,j)=t=1∑T−1​ξt​(i,j)= Expected number of transitions from state iii to state jjj. . We provide a solution for each term. Considering the first term Q(π^∣π)Q( hat{ pi} mid pi)Q(π^∣π) we define the following auxiliary function for πi pi _iπi​ as: . Q(π^∣π)=∑sP(S∣Y,λ)⋅log⁡π^s1Q( hat{ pi} mid pi) = sum_s P(S mid Y, lambda) cdot log hat{ pi}_{s_1}Q(π^∣π)=s∑​P(S∣Y,λ)⋅logπ^s1​​ . Since π^s1 hat{ pi}_{s_1}π^s1​​ only depends on s1s_1s1​, it clear that: . P(S∣Y,λ)=P(s1∣Y,λ)P(S mid Y, lambda) = P(s_1 mid Y, lambda)P(S∣Y,λ)=P(s1​∣Y,λ) . Therefore Q(π^∣pi)Q( hat{ pi} mid pi)Q(π^∣pi) can be rewritten as: . Q(π^∣π)=∑s1P(s1∣Y,λ)⋅log⁡π^s1=∑i=1NP(s1=i∣Y,λ)⋅log⁡π^i=∑i=1Nγt(i)log⁡π^i begin{aligned} Q( hat{ pi} mid pi) &amp;= sum_{s_1}P(s_1 mid Y, lambda) cdot log hat{ pi}_{s_1} &amp;= sum_{i=1}^N P(s_1=i mid Y, lambda) cdot log hat{ pi}_{i} &amp; = sum_{i=1}^N gamma_t(i) log hat{ pi}_{i} end{aligned}Q(π^∣π)​=s1​∑​P(s1​∣Y,λ)⋅logπ^s1​​=i=1∑N​P(s1​=i∣Y,λ)⋅logπ^i​=i=1∑N​γt​(i)logπ^i​​ . Next, we focus on the second term Q(A^∣A)Q( hat{A} mid A)Q(A^∣A) . Q(A^∣A)=∑sP(S∣Y,λ)⋅∑t=2Tlog⁡a^st,st+1Q( hat{A} mid A) = sum_s P(S mid Y, lambda) cdot sum _{t=2}^T log hat{a}_{s_t,s_{t+1}}Q(A^∣A)=s∑​P(S∣Y,λ)⋅t=2∑T​loga^st​,st+1​​ . Similar to Q(π^∣π)Q( hat{ pi} mid pi)Q(π^∣π) , we obtain P(S∣Y,λ)=P(s1∣Y,λ)=P(st,st+1∣Y,λ)P(S mid Y, lambda) = P(s_1 mid Y, lambda) = P(s_t,s_{t+1} mid Y, lambda)P(S∣Y,λ)=P(s1​∣Y,λ)=P(st​,st+1​∣Y,λ) . Therefore . Q(A^∣A)=∑t=1T−1∑sP(st,st+1∣Y,λ)log⁡a^st,st+1=∑t=1T−1∑i=1N∑j=1NP(st=i,st+1=j∣Y,λ)log⁡a^ij=∑t=1T−1∑i=1N∑j=1Nξt(i,j)log⁡a^ij begin{aligned} Q( hat{A} mid A) &amp; = sum _{t=1}^{T-1} sum_s P(s_t,s_{t+1} mid Y, lambda) log hat{a}_{s_t,s_{t+1}} &amp; = sum _{t=1}^{T-1} sum_{i=1}^N sum_{j=1}^N P(s_t=i,s_{t+1}=j mid Y, lambda) log hat{a}_{ij} &amp; = sum _{t=1}^{T-1} sum_{i=1}^N sum_{j=1}^N xi_t(i,j) log hat{a}_{ij} end{aligned}Q(A^∣A)​=t=1∑T−1​s∑​P(st​,st+1​∣Y,λ)loga^st​,st+1​​=t=1∑T−1​i=1∑N​j=1∑N​P(st​=i,st+1​=j∣Y,λ)loga^ij​=t=1∑T−1​i=1∑N​j=1∑N​ξt​(i,j)loga^ij​​ . Finally, we focus on the last term Q(B^∣B)Q( hat{B} mid B)Q(B^∣B) . Q(B^∣B)=∑sP(S∣Y,λ)⋅∑t=1Tlog⁡b^i(yt)Q( hat{B} mid B) = sum_s P(S mid Y, lambda) cdot sum _{t=1}^T log hat{b}_{i}(y_t)Q(B^∣B)=s∑​P(S∣Y,λ)⋅t=1∑T​logb^i​(yt​) . Similary P(S∣Y,λ)=P(st=i∣Y,λ)P(S mid Y, lambda) = P(s_t = i mid Y, lambda)P(S∣Y,λ)=P(st​=i∣Y,λ). Therefore . Q(B^∣B)=∑t=1T∑sP(st=i∣Y,λ)log⁡b^i(yt)=∑t=1T∑i=1Nγt(i)log⁡b^i(yt) begin{aligned} Q( hat{B} mid B) &amp;= sum _{t=1}^T sum_s P(s_t = i mid Y, lambda) log hat{b}_{i}(y_t) &amp; = sum _{t=1}^T sum_{i=1}^N gamma_t(i) log hat{b}_{i}(y_t) end{aligned}Q(B^∣B)​=t=1∑T​s∑​P(st​=i∣Y,λ)logb^i​(yt​)=t=1∑T​i=1∑N​γt​(i)logb^i​(yt​)​ . Thus, we summarize the auxiliary function. . Q(λ^∣λ)=Q(π^∣π)+Q(A^∣A)+Q(B^∣B)Q( hat{ lambda} mid lambda)= Q( hat{ pi} mid pi)+ Q( hat{A} mid A) + Q( hat{B} mid B)Q(λ^∣λ)=Q(π^∣π)+Q(A^∣A)+Q(B^∣B) . Maximization step . In the maximization step, we aim to maximize Q(π^∣π)Q( hat{ pi} mid pi)Q(π^∣π), Q(A^∣A)Q( hat{A} mid A)Q(A^∣A) and Q(B^∣B)Q( hat{B} mid B)Q(B^∣B) with respect to π^ hat{ pi}π^, A^ hat{A}A^ and B^ hat{B}B^ under the following constraints. . ∑_i=1Nπ^=1, and ∑i=1NA^=1 sum _{i=1}^N hat{ pi} = 1, text{ and } sum_{i=1}^N hat{A} = 1∑_i=1Nπ^=1, and i=1∑N​A^=1 . Considering the estimation of initial state probabilities π^=π^i mathbf{ hat{ pi}} = { hat{ pi}_i}π^=π^i​ , we construct a Lagrange function (or Lagrangian): . Q∗(π^∣π)=∑i=1Nγ1(i)log⁡π^i+η(∑i=1Nπ^−1)Q^*( hat{ pi} mid pi) = sum_{i=1}^N gamma_1(i) log hat{ pi}_{i} + eta left( sum_{i=1}^N hat{ pi} - 1 right)Q∗(π^∣π)=i=1∑N​γ1​(i)logπ^i​+η(i=1∑N​π^−1) . Differentiating this Lagrangian with respect to individual probability parameter π^i hat{ pi}_iπ^i​ and set it to zero we obtain. . ∂Q∗(π^∣π)∂π^i=γ1(i)1π^i+η=0π^i=−1ηγ1(i) begin{aligned} frac{ partial Q^*( hat{ pi} mid pi)}{ partial hat{ pi}_i } &amp; = gamma_1(i) frac{1}{ hat{ pi}_i} + eta = 0 hat{ pi}_i &amp;= - frac{1}{ eta} gamma_1(i) end{aligned}∂π^i​∂Q∗(π^∣π)​π^i​​=γ1​(i)π^i​1​+η=0=−η1​γ1​(i)​ . Substituting the above equation into ∑i=1Nπ^=1 sum_{i=1}^N hat{ pi} = 1∑i=1N​π^=1 constraint, we obtain: . ∑i=1Nπ^=∑i=1N−1ηγ1(i)=1⇒η=−∑i=1Nγ1(i) begin{aligned} sum_{i=1}^N hat{ pi} &amp;= sum_{i=1}^N - frac{1}{ eta} gamma_1(i) = 1 Rightarrow eta &amp;= - sum_{i=1}^N gamma_1(i) end{aligned}i=1∑N​π^⇒η​=i=1∑N​−η1​γ1​(i)=1=−i=1∑N​γ1​(i)​ . The ML estimate of new initial state probability is obtained by substituting the above equation into π^i=−1ηγ1(i) hat{ pi}_i = - frac{1}{ eta} gamma_1(i)π^i​=−η1​γ1​(i): . π^i=γ1(i)∑i=1Nγ1(i)=γ1(i) hat{ pi}_i = frac{ gamma_1(i)}{ sum _{i=1}^N gamma_1(i)} = gamma_1(i)π^i​=∑i=1N​γ1​(i)γ1​(i)​=γ1​(i) . In the same manner, we can derive the ML estimates of new state transition probability and new emission probability, which can be shown to be: . a^ij=∑t=1T−1ξt(i,j)∑t=1T−1γt(i) hat{a}_{ij} = frac{ displaystyle sum_{t=1}^{T-1} xi_t(i,j)}{ displaystyle sum_{t=1}^{T-1} gamma_t(i)}a^ij​=t=1∑T−1​γt​(i)t=1∑T−1​ξt​(i,j)​ . And . b^i(k)=∑t=1Tτγt(i)∑t=1Tγt(i) hat{b}_i(k) = frac{ displaystyle sum_{t=1}^{T} tau gamma_t(i)}{ displaystyle sum_{t=1}^{T} gamma_t(i)}b^i​(k)=t=1∑T​γt​(i)t=1∑T​τγt​(i)​ . where . τ={1 if yt=k,0 otherwise  tau = begin{cases} 1 text{ if } y_t = k, 0 text{ otherwise } end{cases}τ={1 if yt​=k,0 otherwise ​ . If we denote the initial model λ{ lambda}λ and the re-estimation model by λ^=(π^i,a^ij,b^j(k)) hat{ lambda}=( hat{ pi}_i, hat{a}_{ij}, hat{b}_j(k))λ^=(π^i​,a^ij​,b^j​(k)). Then i t can be shown that either: . The initial model λ lambdaλ is a critical point of the likelihood in which case λ^=λ hat{ lambda}= lambdaλ^=λ or | P(Y∣λ^)≤P(Y∣λ)P(Y mid hat lambda) leq P(Y mid lambda)P(Y∣λ^)≤P(Y∣λ), i.e we have find the better model from which the observation sequence Y=y1,…YTY=y_1, ldots Y_TY=y1​,…YT​ is more likely to be produced. | Hence we can go on iteractively computing until P(Y∣λ^)P(Y mid hat{ lambda})P(Y∣λ^) is maximazed. . The Baum-Welch Algorithm can be summarized as: . Require: λ←λinit lambda leftarrow lambda ^{init}λ←λinit . repeat | Compute the forward variable αt(i) alpha _t(i)αt​(i) from the forward algorithm | Compute the backward variable βt(i) beta _t(i)βt​(i) from the backward algorithm | Compute the occupation probabilities γt(i) gamma _t(i)γt​(i), and ξt(i,j) xi _t(i,j)ξt​(i,j) | Estimate the new HMM parameters λ^ hat{ lambda}λ^ | Update the HMM parameters λ←λ^ lambda leftarrow hat{ lambda}λ←λ^ | until Convergence | References . L. R. Rabiner, A tutorial on hidden Markov models and selected applications in speech recognition, Proceedings of the IEEE, Vol. 77, No. 2, February 1989. | Shinji Watanabe, Jen-Tzung Chien, Bayesian Speech and Language Processing, Cambridge University Press, 2015. | Viterbi Algorithm in Speech Enhancement and HMM | Nikolai Shokhirev, Hidden Markov Models |",
            "url": "https://sambaiga.github.io/sambaiga/machine%20learning/2017/05/29/hmm-discrete.html",
            "relUrl": "/machine%20learning/2017/05/29/hmm-discrete.html",
            "date": " • May 29, 2017"
        }
        
    
  
    
        ,"post15": {
            "title": "The Basic of Hidden Markov Model",
            "content": "Introduction . HMM is a Markov model whose states are not directly observed; instead, each state is characterized by a probability distribution function. The probability distribution model the observation corresponding to that state. HMM has been extensively used in temporal pattern recognition such as speech, handwriting, gesture recognition, robotics, biological sequences, and recently in energy disaggregation. This tutorial will introduce the basic concept of HMM. . There are two variables in HMM: observed variables and hidden variables. The sequences of hidden variables form a Markov process, as shown in the figure below. In the context of NILM, the hidden variables are used to model states(ON, OFF, standby etc) of individual appliances, and the observed variables are used to model the electric usage. HMMs have been widely used in most of the recently proposed NILM approach. This is because HMM represents well the individual appliance internal states which are not directly observed in the targeted energy consumption. . A typical HMM is characterised by the following: . The finite set of hidden states SSS (e.g ON, stand-by, OFF, etc.) of an appliance, S={s1,s2....,sN}S = {s_1, s_2....,s_N }S={s1​,s2​....,sN​}. | The finite set of MMM observable symbol YYY per states (power consumption) observed in each state, Y={y1,y2....,yM}Y = {y_1, y_2....,y_M }Y={y1​,y2​....,yM​}. The observable symbol YYY can be discrete or a continuous set. | The transition matrix A={aij,1≤i,j≥N} mathbf{A}= {a_{ij},1 leq i,j geq N }A={aij​,1≤i,j≥N} represents the probability of moving from state st−1=is_{t-1}=ist−1​=i to st=js_t =jst​=j such that: aij=P(st=j∣st−1=i)a_{ij} = P(s_{t} =j mid s_{t-1}=i)aij​=P(st​=j∣st−1​=i), with aij≤0a_{ij} leq 0aij​≤0 and where sts_tst​ denotes the state occupied by the system at time ttt. The matrix A mathbf{A}A is NxNN x NNxN. | The emission matrix B={bj(k)} mathbf{B} = {b_j(k) }B={bj​(k)} representing the probability of emission of symbol kkk ϵ epsilonϵ YYY when system state is st=js_t=jst​=j such that: bj(k)=p(yt=k∣st=j)b_j(k) = p(y_t = k mid s_t=j)bj​(k)=p(yt​=k∣st​=j) The matrix B mathbf{B}B is an NxMN x MNxM. The emission probability can be discrete or continous distribution. If the emission is descrete a multinomial distribution is used and multivariate Gaussian distribution is usually used for continous emission. | And the initial state probability distribution π={πi} mathbf{ pi} = { pi_i }π={πi​} indicating the probability of each state of the hidden variable at t=1t = 1t=1 such that, πi=P(q1=si),1≤i≥N pi _i = P(q_1 = s_i), 1 leq i geq Nπi​=P(q1​=si​),1≤i≥N. | . For brief introduction of optuna, you can watch this video . The complete HMM specification requires; . Finite set of hidden states NNN and observation symbols MMM | Length of observation seqences TTT and | Specification of three probability measures A,B mathbf{A}, mathbf{B}A,B and π mathbf{ pi}π | The set of all HMM model parameters is represented by λ=(π,A,B) mathbf{ lambda} =( pi, A, B)λ=(π,A,B). . Since $S$ is not observed, the likelihood function of YYY is given by the joint distribution of $Y$ and $S$ over all possible state. . P(Y∣λ)=∑P(Y,S∣λ)P(Y mid lambda) = sum P(Y, S mid lambda)P(Y∣λ)=∑P(Y,S∣λ) . where . P(Y,S∣λ)=P(Y∣S,λ)P(S∣λ)P(Y,S mid lambda) = P(Y mid S, lambda)P(S mid lambda)P(Y,S∣λ)=P(Y∣S,λ)P(S∣λ) . Note that yty_tyt​ is independent and identically distributed given state sequence S={s1,s2....,sN}S = {s_1, s_2....,s_N }S={s1​,s2​....,sN​}. Also each state at time ttt depend on the state at its previous time t−1t-1t−1. Then . P(Y∣S,λ)=∏t=1TP(yt∣st)P(Y mid S, lambda) = prod_{t=1}^T P(y_t mid s_t)P(Y∣S,λ)=t=1∏T​P(yt​∣st​) . Similary . P(S∣λ)=πs1∏t=2TaijP(S mid lambda) = pi _{s_1} prod _{t=2}^T a_{ij}P(S∣λ)=πs1​​t=2∏T​aij​ . The joint probability is therefore: . P(Y∣λ)=πs1P(y1∣s1)∑∏t=2TaijP(yt∣st)P(Y mid lambda) = pi _{s_1}P(y_1 mid s_1) sum prod_{t=2}^T a_{ij} P(y_t mid s_t)P(Y∣λ)=πs1​​P(y1​∣s1​)∑t=2∏T​aij​P(yt​∣st​) . Three main problems in HMMs . When applying HMM to a real-world problem, three crucial issues must be solved. . Evaluation Problem: Given HMM parameters λ lambdaλ and the observation sequence Y={Y1,Y2....,YM}Y = {Y_1, Y_2....,Y_M }Y={Y1​,Y2​....,YM​}, find P(Y∣λ)P(Y mid lambda)P(Y∣λ) the likelihood of the observation sequence YYY given the model λ lambdaλ. This problem gives a score on how well a given model matches a given observation and allows you to choose the model that best matches the observation. | Decoding Problem: Given HMM parameters λ lambdaλ and the observation seqence Y={Y1,Y2....,YM}Y = {Y_1, Y_2....,Y_M }Y={Y1​,Y2​....,YM​}, find an optimal state sequense S={S1,S2....,SN}S = {S_1, S_2....,S_N }S={S1​,S2​....,SN​} which best explain the observation.This problem attempt to cover the hidden part of the model. | Learning Problem: Given the obseravtion seqence Y={Y1,Y2....,YM}Y = {Y_1, Y_2....,Y_M }Y={Y1​,Y2​....,YM​}, find the model parameters λ lambdaλ that maximize P(Y∣λ)P(Y mid lambda)P(Y∣λ).This problem attempt to optimize the model parameters so as to describe the model. | The first and the second problem can be solved by the dynamic programming algorithms known as the Viterbi algorithm and the Forward-Backward algorithm, respectively. The last one can be solved by an iterative Expectation-Maximization (EM) algorithm, known as the Baum-Welch algorithm. We will discuss the first and the second problem in this post. . Solution to Problem 1 . A straight forward way to solve this problem is to find P(Y∣S,λ)P(Y mid S, lambda)P(Y∣S,λ) for fixed state sequences S={s1,...sT}S = {s_1,...s_T }S={s1​,...sT​} and then sum up over all possible states. This is generally infeasible since it requires about 2TNT2TN^T2TNT multiplications. Nevertheless, this problem can be efficiently solved by using the forward algorithm as follows: . The forward-backward Algorithm . Let us define the forward variable . αt(i)=P(y1,…yt,st=i∣λ) alpha _t(i)=P(y_1, ldots y_t, s_t=i mid lambda)αt​(i)=P(y1​,…yt​,st​=i∣λ) . the probability of the partial observation sequences y1…yty_1 ldots y_ty1​…yt​ up to time ttt and the state st=is_t =ist​=i at time ttt given the model λ{ lambda}λ. We also define an emission probability given HMM state iii at time ttt as bi(yt)b_i(y_t)bi​(yt​). . Forward-Algorithm . Initialization . Let . α1(i)=P(y1,s1=i∣λ)=P(y1∣s1=i,λ)P(s1=i∣λ)=πibi(y1) for 1≤i≥N begin{aligned} alpha _1(i)&amp;=P(y_1, s_1=i mid lambda) &amp; = P(y_1 mid s_1=i, lambda)P(s_1=i mid lambda) &amp;= pi _i b_i(y_1) text{ for } 1 leq i geq N end{aligned}α1​(i)​=P(y1​,s1​=i∣λ)=P(y1​∣s1​=i,λ)P(s1​=i∣λ)=πi​bi​(y1​) for 1≤i≥N​ . Induction . For t=2,3...Tt=2,3...Tt=2,3...T and 1≤i≥N1 leq i geq N1≤i≥N, compute: . αt(i)=P(y1…yt,st=i∣λ)=∑j=1NP(y1…yt,st−1=j,st=i∣λ)=∑j=1NP(yt∣st=i,y1,…yt−1,st−1=j,λ)×P(st=i∣y1…yt−1…,st−1=j,λ)×P(y1…yt−1,st−1=j,λ)=P(yt∣st=i,λ)∑j=1NP(st=i∣st−1=j)⋅P(y1,…yt−1,st−1)=bi(yt)∑j=1Nαt−1(i)aij begin{aligned} alpha _{t}(i) &amp; = P(y_1 ldots y_t, s_t=i mid lambda) &amp;= displaystyle sum_{j=1}^{N} P(y_1 ldots y_{t}, s_{t-1}=j,s_t=i mid lambda) &amp;= displaystyle sum_{j=1}^{N} P(y_t mid s_t=i, y_1, ldots y_{t-1}, s_{t-1}=j, lambda) &amp; times P(s_t=i mid y_1 ldots y_{t-1} ldots , s_{t-1}=j, lambda) &amp; times P(y_1 ldots y_{t-1}, s_{t-1}=j, lambda) &amp; = P(y_t mid s_t=i, lambda) displaystyle sum_{j=1}^{N} P(s_t=i mid s_{t-1}=j) cdot P(y_1, ldots y_{t-1}, s_{t-1}) &amp; = b_i(y_{t}) displaystyle sum_{j=1}^{N} alpha _{t-1}(i)a_{ij} end{aligned}αt​(i)​=P(y1​…yt​,st​=i∣λ)=j=1∑N​P(y1​…yt​,st−1​=j,st​=i∣λ)=j=1∑N​P(yt​∣st​=i,y1​,…yt−1​,st−1​=j,λ)×P(st​=i∣y1​…yt−1​…,st−1​=j,λ)×P(y1​…yt−1​,st−1​=j,λ)=P(yt​∣st​=i,λ)j=1∑N​P(st​=i∣st−1​=j)⋅P(y1​,…yt−1​,st−1​)=bi​(yt​)j=1∑N​αt−1​(i)aij​​ . Termination . From αt(i)=P(y1,...yt,st=i∣λ) alpha _t(i)=P(y_1,...y_t, s_t=i mid lambda)αt​(i)=P(y1​,...yt​,st​=i∣λ), it cear that: . P(Y∣λ)=∑i=1NP(y1,…yT,sT=i∣λ)=∑i=1NαT(i) begin{aligned} P(Y mid lambda) &amp;= displaystyle sum_{i=1}^{N} P(y_1, ldots y_T, s_T = i mid lambda) &amp;= displaystyle sum_{i=1}^{N} alpha _T(i) end{aligned}P(Y∣λ)​=i=1∑N​P(y1​,…yT​,sT​=i∣λ)=i=1∑N​αT​(i)​ . The forward algorithm only requires about N2TN^2TN2T multiplications and is it can be implemented in Python as follows. . def forward(obs_seq): T = len(obs_seq) N = A.shape[0] alpha = np.zeros((T, N)) alpha[0] = pi*B[:,obs_seq[0]] for t in range(1, T): alpha[t] = alpha[t-1].dot(A) * B[:, obs_seq[t]] return alpha def likelihood(obs_seq): # returns log P(Y mid model) # using the forward part of the forward-backward algorithm return forward(obs_seq)[-1].sum() . Backward Algorithm . This is the same as the forward algorithm discussed in the previous sectionexcept that it start at the end and works backward toward the beginning. We first define the backward variable βt(i)=P(yt+1,yt+2…yT∣st=i,λ) beta_t(i)=P(y_{t+1},y_{t+2} ldots y_{T} mid s_t=i, { lambda})βt​(i)=P(yt+1​,yt+2​…yT​∣st​=i,λ): probability of the partial observed sequence from t+1t+1t+1 to the end at TTT given state iii at time ttt and the model λ lambdaλ. . Then βt(i) beta_t(i)βt​(i) can be recursively computed as follows. . Initialization . Let βT(i)=1 beta_{T}(i)= 1βT​(i)=1, for 1≤i≥N1 leq i geq N1≤i≥N . Induction . For t=T−1,T−2,…1t =T-1, T-2, ldots1t=T−1,T−2,…1 for 1≤i≥N1 leq i geq N1≤i≥N and by using the sum and product rules, we can rewrite βt(j) beta_t(j)βt​(j) as: . βt(i)=P(yt+1,…yT∣st=j,λ)=∑i=1NP(yt+1…yT,st+1=i∣st=j,λ)=∑i=1NP(yt+1…yT,st+1=i,st=j,λ)⋅P(st+1=i∣st=j)=∑i=1NP(yt+2…yT,st+1=i,λ)⋅P(yt+1∣st+1=i,λ)⋅P(st+1=i∣st=j)=∑i=1Naijbi(yt+1)βt+1(i) begin{aligned} beta_t(i)&amp;=P(y_{t+1}, ldots y_{T} mid s_t=j, { lambda}) &amp;= displaystyle sum_{i=1}^{N} P(y_{t+1} ldots y_T, s_{t+1}=i mid s_t=j, lambda) &amp; = displaystyle sum_{i=1}^{N} P(y_{t+1} ldots y_T, s_{t+1}=i, s_t=j, lambda) cdot P(s_{t+1}=i mid s_t=j) &amp;= displaystyle sum_{i=1}^{N} P(y_{t+2} ldots y_T, s_{t+1}=i, lambda) cdot P(y_{t+1} mid s_{t + 1}=i, lambda) cdot P(s_{t+1}=i mid s_t=j) &amp; = displaystyle sum_{i=1}^{N} a_{ij}b_i(y_{t+1}) beta _{t+1}(i) end{aligned}βt​(i)​=P(yt+1​,…yT​∣st​=j,λ)=i=1∑N​P(yt+1​…yT​,st+1​=i∣st​=j,λ)=i=1∑N​P(yt+1​…yT​,st+1​=i,st​=j,λ)⋅P(st+1​=i∣st​=j)=i=1∑N​P(yt+2​…yT​,st+1​=i,λ)⋅P(yt+1​∣st+1​=i,λ)⋅P(st+1​=i∣st​=j)=i=1∑N​aij​bi​(yt+1​)βt+1​(i)​ . Termination . β0=P(Y∣λ)=∑i=1NP(y1,…yT,s1=i)=∑i=1NP(y1,…yT∣s1=i)⋅P(s1=i)=∑i=1NP(y1∣s1=i)⋅P(y2,…yT∣s1=i)⋅P(s1=i)=∑i=1Nπibi(y1)β1(i) begin{aligned} beta_{0} &amp; = P(Y mid lambda) &amp; = displaystyle sum_{i=1}^{N} P(y_1, ldots y_T, s_1=i) &amp;= displaystyle sum_{i=1}^{N} P(y_1, ldots y_T mid s_1=i) cdot P(s_1=i) &amp; = displaystyle sum_{i=1}^{N} P(y_1 mid s_1=i) cdot P(y_2, ldots y_T mid s_1=i) cdot P(s_1=i) &amp; = displaystyle sum_{i=1}^{N} pi _i b_i(y_1) beta _1(i) end{aligned}β0​​=P(Y∣λ)=i=1∑N​P(y1​,…yT​,s1​=i)=i=1∑N​P(y1​,…yT​∣s1​=i)⋅P(s1​=i)=i=1∑N​P(y1​∣s1​=i)⋅P(y2​,…yT​∣s1​=i)⋅P(s1​=i)=i=1∑N​πi​bi​(y1​)β1​(i)​ . Python implementation of the forward algorithm is as shown below; . def backward(obs_seq): N = A.shape[0] T = len(obs_seq) beta = np.zeros((N,T)) beta[:,-1:] = 1 for t in reversed(range(T-1)): for n in range(N): beta[n,t] = np.sum(beta[:,t+1] * A[n,:] * B[:, obs_seq[t+1]]) return beta . Posterior Probability . The forward variable αt(i) alpha _t(i)αt​(i) and backward variable βt(i) beta _t(i)βt​(i) are used to calculate the posterior probability of a specific case. Now for t=1...Tt=1...Tt=1...T and i=1..Ni=1..Ni=1..N, let define posterior probability γt(i)=P(st=i∣Y,λ) gamma_t(i)=P(s_t=i mid Y, lambda)γt​(i)=P(st​=i∣Y,λ) the probability of being in state st=is_t = ist​=i at time ttt given the observation YYY and the model λ lambdaλ. . γt(i)=P(st=1,Y∣λ)P(Y∣λ)=P(y1,…yt,st=1,∣λ)P(Y∣λ) begin{aligned} gamma_t(i) &amp; = frac{P(s_t=1, Y mid lambda)}{P(Y mid lambda)} &amp;= frac{P(y_1, ldots y_t, s_t=1, mid lambda)}{P(Y mid lambda)} end{aligned}γt​(i)​=P(Y∣λ)P(st​=1,Y∣λ)​=P(Y∣λ)P(y1​,…yt​,st​=1,∣λ)​​ . Consider: . P(y1,…yt,st=1,∣λ)=P(y1,…yt∣st=1,λ)⋅P(yt+1,…yT∣st=1,λ)⋅P(st=i∣λ)=αt(i)⋅βt(i) begin{aligned} P(y_1, ldots y_t, s_t=1, mid lambda) &amp; = P(y_1, ldots y_t mid s_t=1, lambda) cdot P(y_{t+1}, ldots y_T mid s_t=1, lambda) cdot P(s_t =i mid lambda) &amp; = alpha _t(i) cdot beta _t(i) end{aligned}P(y1​,…yt​,st​=1,∣λ)​=P(y1​,…yt​∣st​=1,λ)⋅P(yt+1​,…yT​∣st​=1,λ)⋅P(st​=i∣λ)=αt​(i)⋅βt​(i)​ . Thus . γt(i)=αt(i)⋅βt(i)P(Y∣λ) gamma_t(i) = frac{ alpha _t(i) cdot beta _t(i)}{P(Y mid lambda)}γt​(i)=P(Y∣λ)αt​(i)⋅βt​(i)​ . where . P(Y∣λ)=∑i=1NαT(i)P(Y mid { lambda}) = displaystyle sum_{i=1}^{N} alpha _T(i)P(Y∣λ)=i=1∑N​αT​(i) . In python: . def gamma(obs_seq): alpha = forward(obs_seq) beta = backward(obs_seq) obs_prob = likelihood(obs_seq) return (np.multiply(alpha,beta.T) / obs_prob) . We can use γt(i) gamma_t(i)γt​(i) to find the most likely state at time ttt which is the state st=is_t=ist​=i for which γt(i) gamma_t(i)γt​(i) is maximum. This algorithm works fine in the case when HMM is ergodic i.e., there is the transition from any state to any other state. If applied to an HMM of another architecture, this approach could give a sequence that may not be a legitimate path because some transitions are not permitted. To avoid this problem, Viterbi algorithm is the most common decoding algorithm used. . Viterbi Algorithm . Viterbi is a kind of dynamic programming algorithm that makes uses of a dynamic programming trellis. . The virtebi algorithm offer an efficient way of finding the single best state sequence.Let define the highest probability along a single path, at time ttt, which accounts for the first ttt observations and ends in state jjj using a new notation: . δt(i)=max⁡s1,…st−1P(s1,…st=1,y1,…yt∣λ) begin{aligned} delta_t(i) &amp; = max_{s_1, ldots s_{t-1}} P(s_1, ldots s_t =1, y_1, ldots y_t mid lambda) end{aligned}δt​(i)​=s1​,…st−1​max​P(s1​,…st​=1,y1​,…yt​∣λ)​ . By induction, a recursive formula of δt+1(i) delta_{t+1}(i)δt+1​(i) from δt(i) delta_t(i)δt​(i) is derived to calculate this probability as follows: . Consider the joint distribution appearing in δt+1(i) delta_{t+1}(i)δt+1​(i), which can be rewritten when st+1=is_{t+1}=ist+1​=i and st=js_t = jst​=j as: . P(s1,…,st=j,st+1=i,y1,…yt,yt+1∣λ)=P(s1…st=j,y1,…yt∣λ)×P(st+1=i,yt+1∣s1,…st,y1,…yt,λ)=P(s1…st=j,y1,…yt∣λ)⋅P(st+1∣st,λ)×P(yt+1∣st+1,λ)=P(s1…st=j,y1,…yt∣λ)⋅aijbi(yt+1) begin{aligned} P(s_1, ldots, s_t=j,s_{t+1}=i, y_1, ldots y_t, y_{t+1} mid lambda) &amp; = P(s_1 ldots s_t=j, y_1, ldots y_t mid lambda) &amp; times P(s_{t+1}=i,y_{t+1} mid s_1, ldots s_t, y_1, ldots y_t, lambda) &amp; = P(s_1 ldots s_t=j, y_1, ldots y_t mid lambda) cdot P(s_{t+1} mid s_t, lambda) &amp; times P(y_{t+1} mid s_{t+1}, lambda) &amp; = P(s_1 ldots s_t=j, y_1, ldots y_t mid lambda) cdot a_{ij}b_i(y_{t+1}) end{aligned}P(s1​,…,st​=j,st+1​=i,y1​,…yt​,yt+1​∣λ)​=P(s1​…st​=j,y1​,…yt​∣λ)×P(st+1​=i,yt+1​∣s1​,…st​,y1​,…yt​,λ)=P(s1​…st​=j,y1​,…yt​∣λ)⋅P(st+1​∣st​,λ)×P(yt+1​∣st+1​,λ)=P(s1​…st​=j,y1​,…yt​∣λ)⋅aij​bi​(yt+1​)​ . Thus δt+1(i) delta_{t+1}(i)δt+1​(i) is computed recursively from δt+1(j) delta_{t+1}(j)δt+1​(j) as: . δt+1(i)=max⁡s1,…st=jP(s1…st=j,y1,…yt∣λ)⋅aijbi(yt+1)=max⁡j[δt(j)aij]⋅bi(yt+1) begin{aligned} delta_{t+1}(i) &amp;= max_{s_1, ldots s_{t}=j} P(s_1 ldots s_t=j, y_1, ldots y_t mid lambda) cdot a_{ij}b_i(y_{t+1}) &amp; = max_{j} Big[ delta_t(j) a_{ij} Big] cdot b_i(y_{t+1}) end{aligned}δt+1​(i)​=s1​,…st​=jmax​P(s1​…st​=j,y1​,…yt​∣λ)⋅aij​bi​(yt+1​)=jmax​[δt​(j)aij​]⋅bi​(yt+1​)​ . Therefore, we need to keep track of the state that maximizes the above equation to backtrack to the single best state sequence in the following Viterbi algorithm: . Initialization . For 1≤i≥N1 leq i geq N1≤i≥N, let: . δ1(i)=πsibi(y1)Θ1(i)=0 begin{aligned} delta _1(i)&amp;= pi _{s_i}b_i(y_1) Theta _1(i)&amp;=0 end{aligned}δ1​(i)Θ1​(i)​=πsi​​bi​(y1​)=0​ . Recursion . Calculate the ML (maximum likelihood) state sequences and their probabilities. For t=2,3,...Tt=2,3,...Tt=2,3,...T and 1≤i≥N1 leq i geq N1≤i≥N . δt(i)=max⁡jϵ1,..N[δt−1(j)aij]⋅bi(yt)Θt(i)=arg⁡max⁡j[δt−1(j)aij] begin{aligned} delta_t(i) &amp; = displaystyle max_{j epsilon{1,..N}} Big[ delta_{t-1}(j)a_{ij} Big] cdot b_i(y_t) Theta_t(i) &amp; = arg max_j Big[ delta_{t-1}(j)a_{ij} Big] end{aligned}δt​(i)Θt​(i)​=jϵ1,..Nmax​[δt−1​(j)aij​]⋅bi​(yt​)=argjmax​[δt−1​(j)aij​]​ . Termination: . Retrieve the most likely final state . P^=max⁡jϵ1,..N[δT(j)]S^T=arg⁡max⁡j[δT(j)] begin{aligned} hat{P} &amp;= displaystyle max_{j epsilon{1,..N}}[ delta_T(j)] hat{S}_T &amp; = arg max_j [ delta_T(j)] end{aligned}P^S^T​​=jϵ1,..Nmax​[δT​(j)]=argjmax​[δT​(j)]​ . State sequence backtracking: . Retrieve the most likely state sequences (Viterbi path) . S^t=Θt+1(S^t+1), where t=T−1,T−2,…1 hat{S}_t = Theta_{t+1}( hat{S}_{t+1}) text{, where } t=T-1,T-2, ldots1S^t​=Θt+1​(S^t+1​), where t=T−1,T−2,…1 . The Viterbi algorithm uses the same schema as the Forward algorithm except for two differences: . It uses maximization in place of summation at the recursion and termination steps. | It keeps track of the arguments that maximize δt(i) delta_t(i)δt​(i) for each ttt and iii, storing them in the N by T matrix Θ ThetaΘ. This matrix is used to retrieve the optimal state sequence at the backtracking step. | Python implementation of virtebi algorithm . def viterbi(obs_seq): # returns the most likely state sequence given observed sequence x # using the Viterbi algorithm T = len(obs_seq) N = A.shape[0] delta = np.zeros((T, N)) psi = np.zeros((T, N)) delta[0] = pi*B[:,obs_seq[0]] for t in range(1, T): for j in range(N): delta[t,j] = np.max(delta[t-1]*A[:,j]) * B[j, obs_seq[t]] psi[t,j] = np.argmax(delta[t-1]*A[:,j]) # backtrack states = np.zeros(T, dtype=np.int32) states[T-1] = np.argmax(delta[T-1]) for t in range(T-2, -1, -1): states[t] = psi[t+1, states[t+1]] return states . To summarize, we can compute the following from HMM: . The marginalized likelihood function P(Y∣λ)P(Y mid lambda)P(Y∣λ) from the forward or backward algorithm. | The posterior probability γt(i)=P(st=i∣Y,λ) gamma_t(i) = P(s_t=i mid Y, lambda)γt​(i)=P(st​=i∣Y,λ) from the forward–backward algorithm. | The optimal state sequence S^=max⁡sP(S∣Y,λ)=max⁡sP(S,Y∣λ) hat{S} = max_{s} P(S mid Y, lambda) = max_{s} P(S, Y mid lambda)S^=maxs​P(S∣Y,λ)=maxs​P(S,Y∣λ)from the Viterbi algorithm. | The segmental joint likelihood function P(S^,Y∣λ)P( hat{S},Y mid lambda)P(S^,Y∣λ) from the Viterbi algorithm. | These values are used in the decoding step, and the training step of estimating model parameters λ lambdaλ. . Example 1 . Consider the Bob-Alice example as described here. Two friends, Alice and Bob, who live far apart and talk together daily over the telephone about what they did that day. Bob is only interested in three activities: walking in the park, shopping, and cleaning his apartment. The choice of what to do is determined exclusively by the weather on a given day. Alice has no specific information about the weather where Bob lives, but she knows general trends. Based on what Bob tells her he did each day, Alice tries to guess what the weather must have been. . Alice believes that the weather operates as a discrete Markov chain. There are two states, “Rainy” and “Sunny”, but she cannot observe them directly; that is, they are hidden from her. On each day, there is a pure chance that Bob will perform one of the following activities, depending on the weather: “walk”, “shop”, or “clean”. Since Bob tells Alice about his actions, those are the observations. . states = (&#39;Rainy&#39;, &#39;Sunny&#39;) observations = (&#39;walk&#39;, &#39;shop&#39;, &#39;clean&#39;) pi = np.array([0.6, 0.4]) #initial probability A = np.array([[0.7, 0.3],[0.4, 0.6]]) #Transmission probability B = np.array([[0.1, 0.4, 0.5],[0.6, 0.3, 0.1]]) #Emission probability . Suppose Bob says walk, clean, shop, shop, clean, walk. What will Alice hears. . bob_says = np.array([0, 2, 1, 1, 2, 0]) alice_hears=viterbi(bob_says) print(&quot;Bob says:&quot;, &quot;, &quot;,list(map(lambda y: observ_bob[y], bob_says))) print(&quot;Alice hears:&quot;, &quot;, &quot;, list(map(lambda s: states_bob[s], alice_hears))) . (&#39;Bob says:&#39;, &#39;walk, clean, shop, shop, clean, walk&#39;) (&#39;Alice hears:&#39;, &#39;Sunny, Rainy, Rainy, Rainy, Rainy, Sunny&#39;) The notebook with codes for the above example can be found in here . References . L. R. Rabiner, A tutorial on hidden Markov models and selected applications in speech recognition, Proceedings of the IEEE, Vol. 77, No. 2, February 1989. | Shinji Watanabe, Jen-Tzung Chien, Bayesian Speech and Language Processing, Cambridge University Press, 2015. | Viterbi Algorithm in Speech Enhancement and HMM | Nikolai Shokhirev, Hidden Markov Models |",
            "url": "https://sambaiga.github.io/sambaiga/machine%20learning/2017/05/03/hmm-intro.html",
            "relUrl": "/machine%20learning/2017/05/03/hmm-intro.html",
            "date": " • May 3, 2017"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "Portfolio",
          "content": "Anthony Faustine is a Data Scientist at CeADAR (UCD), Dublin, Ireland with over four years of successful experience in data analytics and Artificial Intelligence techniques for multiple applications. He effectively investigates methods for novel approaches to problems and develops prototypes to assess their viability. Although Anthony is a person who takes the initiative, he has a strong team spirit with experience working in a highly international environment. He is proficient in machine learning techniques and deep learning for multiple applications with sound data analytical, data visualization, and programming skills, especially in Python. . At CeADER, Anthony is devising and implementing data analytics/AI technical solutions for various application domains. He is also involved in the research and development of the applicability of Artificial Intelligence for Earth Observation (AI4EO). He is currently finalizing a six-month research project that explores how EO imagery data can be combined with geospatial data to automate the process of generating an annotated dataset for building AI models specific to EO imagery. During this time, Mr. Anthony successfully led the team to develop a flexible end-to-end pipeline that combines satellite imagery and geo-referenced dataset to create the annotated dataset and build machine learning models. He also works on another project in partnership with the European Space Agency(ESA) to investigate specifications and best practices for creating the EO dataset for AI applications. . Mr. Faustine received the B.sc. Degree in Electronics Science and Communication from the University of Dar es Salaam, Tanzania, and the M.sc. Degree in Telecommunications Engineering from the University of Dodoma, Tanzania, in 2010. From 2010 to 2017, he worked as an assistant lecturer at the University of Dodoma, Tanzania, where he was involved in several research projects within the context of ICT4D. . In 2017, Anthony joined IDLab, imec research group of the University of Ghent, in Belgium as a Machine learning researcher. His research focused on machine learning techniques applied to energy smart-meter data. He was also involved in the development of machine learning models that analyze data monitored from the internet of things (IoT) devices to detect and classify activities in the smart-homes environment. This opportunity has allowed me to drastically expand his research, data analytics, and machine learning skills. Working closely with other departments allowed him to improve his interpersonal skills and present complex technical information to technical and non-technical personnel. Since Feb 2020, Mr. Faustine has been working with Dr. Lucas Pereira of ITI, LARSyS, Técnico Lisboa &amp; Prsma.com on robust machine learning techniques for energy-disaggregation and how energy-disaggregation could solve real-world problems in smart-grid. These opportunities have allowed him to drastically expand his technical ability, critical thinking, project management, and research skills. . By participating in different research projects, Mr. Faustine has learned to describe the project’s specific objectives and its excellence and impact. He has also gained experience writing grant proposals and scientific publications, handling and analyzing large datasets, and generating insights from data. . Moreover, Mr. Faustine is competent in communicating complex ideas to groups of different disciplines in simple language. He acquired these abilities from his previous job as an assistant lecturer. The competence advanced through volunteer activities where He organized and facilitated a capacity development workshop on data science and machine learning to university students in Tanzania. As a result, Mr. Faustine can conduct training, demonstrations, and sharing results to technical and non-technical audiences. . Mr. Faustine’s research interests lie in the intersections between Machine learning, Signal processing, and Computational Sustainability. He works towards bridging the gap between research and real-world applicability of machine learning for sustainable development. .",
          "url": "https://sambaiga.github.io/sambaiga/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  
      ,"page2": {
          "title": "Blogs",
          "content": "",
          "url": "https://sambaiga.github.io/sambaiga/post/",
          "relUrl": "/post/",
          "date": ""
      }
      
  

  

  
      ,"page4": {
          "title": "Project",
          "content": "",
          "url": "https://sambaiga.github.io/sambaiga/project/",
          "relUrl": "/project/",
          "date": ""
      }
      
  

  
      ,"page5": {
          "title": "Publications",
          "content": "2020 . A. Faustine, L. Pereira, and C. Klemenjak. Adaptive Weighted Recurrence Graphs for Appliance Recognition in Non-Intrusive Load Monitoring. IEEE Transactions on Smart Grid, :1–1, 2020. [doi: 10.1109/TSG.2020.3010621] [Abs] [] [] To this day, hyperparameter tuning remains a cumbersome task in Non-Intrusive Load Monitoring (NILM) research, as researchers and practitioners are forced to invest a considerable amount of time in this task. This paper proposes adaptive weighted recurrence graph blocks (AWRG) for appliance feature representation in event-based NILM. An AWRG block can be combined with traditional deep neural network architectures such as Convolutional Neural Networks for appliance recognition. Our approach transforms one cycle per activation current into an weighted recurrence graph and treats the associated hyper-parameters as learn-able parameters. We evaluate our technique on two energy datasets, the industrial dataset LILACD and the residential PLAID dataset. The outcome of our experiments shows that transforming current waveforms into weighted recurrence graphs provides a better feature representation and thus, improved classification results. It is concluded that our approach can guarantee uniqueness of appliance features, leading to enhanced generalisation abilities when compared to the widely researched V-I image features. Furthermore, we show that the initialisation parameters of the AWRG’s have a significant impact on the performance and training convergence. . | Anthony Faustine and Lucas Pereira. Multi-label Learning for Appliance Recognition in NILM using Fryze-Current Decomposition and Convolutional Neural Network. Energies, 2020. [Abs] The advance in energy-sensing and smart-meter technologies have motivated the use of a Non-Intrusive Load Monitoring (NILM), a data-driven technique that recognizes active end-use appliances by analyzing the data streams coming from these devices. NILM offers an electricity consumption pattern of individual loads at consumer premises, which is crucial in the design of energy efficiency and energy demand management strategies in buildings. Appliance classification, also known as load identification is an essential sub-task for identifying the type and status of an unknown load from appliance features extracted from the aggregate power signal. Most of the existing work for appliance recognition in NILM uses a single-label learning strategy which, assumes only one appliance is active at a time. This assumption ignores the fact that multiple devices can be active simultaneously and requires a perfect event detector to recognize the appliance. In this paper proposes the Convolutional Neural Network (CNN)-based multi-label learning approach, which links multiple loads to an observed aggregate current signal. Our approach applies the Fryze power theory to decompose the current features into active and non-active components and use the Euclidean distance similarity function to transform the decomposed current into an image-like representation which, is used as input to the CNN. Experimental results suggest that the proposed approach is sufficient for recognizing multiple appliances from aggregated measurements. . | Anthony Faustine and Lucas Pereira. Improved Appliance Classification in Non-Intrusive Load Monitoring Using Weighted Recurrence Graph and Convolutional Neural Networks. Energies, 13(13) :3374, 2020. [doi: 10.3390/en13133374] [Abs] [] Appliance recognition is one of the vital sub-tasks of NILM in which a machine learning classier is used to detect and recognize active appliances from power measurements. The performance of the appliance classifier highly depends on the signal features used to characterize the loads. Recently, different appliance features derived from the voltage–current (V–I) waveforms have been extensively used to describe appliances. However, the performance of V–I-based approaches is still unsatisfactory as it is still not distinctive enough to recognize devices that fall into the same category. Instead, we propose an appliance recognition method utilizing the recurrence graph (RG) technique and convolutional neural networks (CNNs). We introduce the weighted recurrent graph (WRG) generation that, given one-cycle current and voltage, produces an image-like representation with more values than the binary output created by RG. Experimental results on three different sub-metered datasets show that the proposed WRG-based image representation provides superior feature representation and, therefore, improves classification performance compared to V–I-based features . | 2019 . Dirk Deschrijver Anthony Faustine and Tom Dhaene. Improved Appliance Classification in NILM using Recurrence Plots and Convolutional Neural Networks. In: EU NILM Workshop, Thessaloniki, Greece 2019. [] | 2017 . Anthony Faustine. Convolutional Neural Network for Appliance Classification in NILM. In: Data Science Africa, Arusha, Tanzania 2017. | Anthony Faustine, Nerey Henry Mvungi, Shubi Kaijage, and Kisangiri Michael. A Survey on Non-Intrusive Load Monitoring Methodies and Techniques for Energy Disaggregation Problem. CoRR, abs/1703.00785 2017. [doi: 1223334555] [Abs] [arXiv] [] The rapid urbanization of developing countries coupled with explosion in construction of high rising buildings and the high power usage in them calls for conservation and efficient energy program. Such a program require monitoring of end-use appliances energy consumption in real-time. The worldwide recent adoption of smart-meter in smart-grid, has led to the rise of Non-Intrusive Load Monitoring (NILM); which enables estimation of appliance-specific power consumption from building’s aggregate power consumption reading. NILM provides households with cost-effective real-time monitoring of end-use appliances to help them understand their consumption pattern and become part and parcel of energy conservation strategy. This paper presents an up to date overview of NILM system and its associated methods and techniques for energy disaggregation problem. This is followed by the review of the state-of-the art NILM algorithms. Furthermore, we review several performance metrics used by NILM researcher to evaluate NILM algorithms and discuss existing benchmarking framework for direct comparison of the state of the art NILM algorithms. Finally, the paper discuss potential NILM use-cases, presents an overview of the public available dataset and highlight challenges and future research directions. . | 2016 . Maria Gabriel Faustine Anthony and Bertha Shao. Open Source Cellular Technologies for Cost Effective Cellular Connectivity in Rural Areas. International Journal of Computer Applications, 146(15) 2016. [doi: 10.5120/ijca2016910894] [Abs] [] [] Cellular coverage is often a challenge in low population density and low income rural areas of the developing world like Tanzania. This is because big Telecom companies defer from deploying their expensive infrastructure in these areas fearing operations cost. It is proposed that the use of cellular open source technology as the basis for a new rural cellular network can go a long way in meeting this challenge by providing coverage in rural areas whilst simultaneously bringing down the cost of communication. This paper provides survey of recent open source cellular technologies. It further presents a prototype based on Open BTS for cellular connectivity in developing countries. In lab performance test for the proposed prototype confirm the feasibility of deploying cellular network based on open source technologies as an alternative to conventional mobile operator networks in a bid to solve the challenge. . | 2015 . Aloys N Mvuma Nyaura Kibinda and Anthony Faustine. Handover Algorithm for Machine Type Communication in LTE Network. Informatics and Virtual Education, 3(1) 2015. [Abs] [] Machine Type Communication (MTC) is a new type of data communication between machines and devices without human interactions. Long Term Evolution (LTE) is a recent third Generation Partnership Program (3GPP) cellular standard and is a promising technology to support future MTC data traffic. This paper evaluates two existing handover algorithms namely A2-A4-RSRQ and A3-RSRP. Based on the analysis of the optimal settings of both algorithms, the performances of the selected algorithms were compared and the results proved that A2-A4-RSRQ performs better than A3-RSRP. A2-A4-RSRQ handover algorithm is able to maintain acceptable throughput and handover delay as per 3GPP specification. . | 2014 . Anthony Faustine and Aloys N. Mvuma. Ubiquitous Mobile Sensing for Water Quality Monitoring and Reporting within Lake Victoria Basin. Wireless Sensor Network, 6(12) :257–264, 2014. [doi: 10.4236/wsn.2014.612025] [Abs] [] [] [] As the human population growth and industry pressure in most developing countries continue to increase, effective water quality monitoring and evaluation has become critical for water resources management programs. This paper presents the ubiquitous mobile sensing system for water quality data collection and monitoring applications in developing countries. The system was designed based on the analysis of the existing solution. Open source hardware and software was used to develop the prototype of the system. Field testing of the system conducted in Nkokonjero, Uganda and Mwanza, Tanzania verified the functionalities of the system and its practical application in actual environment. Results show that proposed solution is able to collect and present data in a mobile environment. . | Aloys N Mvuma Anthony Faustine and Hector J Mongi. Wireless Sensor Networks for Water Quality Monitoring and Control within Lake Victoria Basin: Prototype Development. Wireless Sensor Network, 6(12) :281–290, 2014. [doi: 10.4236/wsn.2014.612027] [Abs] [] [] [] The need for effective and efficient monitoring, evaluation and control of water quality in Lake Victoria Basin (LVB) has become more demanding in this era of urbanization, population growth and climate change and variability. Traditional methods that rely on collecting water samples, testing and analyses in water laboratories are not only costly but also lack capability for real-time data capture, analyses and fast dissemination of information to relevant stakeholders for making timely and informed decisions. In this paper, a Water Sensor Network (WSN) system prototype developed for water quality monitoring in LVB is presented. The development was preceded by evaluation of prevailing environment including availability of cellular network coverage at the site of operation. The system consists of an Arduino microcontroller, water quality sensors, and a wireless network connection module. It detects water temperature, dissolved oxygen, pH, and electrical conductivity in real-time and disseminates the information in graphical and tabular formats to relevant stakeholders through a web-based portal and mobile phone platforms. The experimental results show that the system has great prospect and can be used to operate in real world environment for optimum control and protection of water resources by providing key actors with relevant and timely information to facilitate quick action taking. . | Deo Shao Anthony Faustine and Aloys Mvuma. Combating Medical Drug Counterfeit in Tanzania: The Role of Technology. In: Proceedings of the 1st Cotul Annual Conference, , Ruaha Catholic University, Iringa, Tanzania, 2014. [Abs] he infiltration of Counterfeit Drugs (CDs) in the Pharmaceutical Supply Chain (PSC) is adversely affecting health sectors in their efforts to provide quality health services to the public. According to the World Health Organisation (WHO), over 30 percent of anti-malaria drugs sold in the developing countries are substandard. Furthermore, the Confederation of Tanzania Industries (CTI) estimated that 60 percent of the medicines imported into Tanzania are counterfeits. Several initiatives have been taken in an attempt to curb the selling of CDs. However, the effectiveness of these initiatives remains questionable. There is an urgent need to formulate more effective strategies to secure the PSC by involving all stakeholders. In this regard, technology-based solution could be an effective uptake in mitigating CDs. This study assesses how the technology-based system can secure PSC and enable medical drugs verification in Tanzania. The proven adoption of Information and Communication Technologies (ICTs), especially mobile technology, could be leveraged to enable the enforcement of laws and regulations and advocate community awareness on medical safety . | 2013 . Anthony Faustine and Aloys N Mvuma. Design and Simulation of Wireless Sensor Network for Water Quality Monitoring Around Lake Victoria. Journal of Informatics and Virtual Education, :37, 2013. | Anthony Faustine and Lucian Ngeze. Enhancing Teaching and Learning Communication Network Courses in Higher Learning Institutions in Tanzania Using Simulations. Journal of Informatics and Virtual Education, :30, 2013. | 2012 . Anthony Faustine. Design of Wireless Sensor Network for Water Quality Monitoring around Lake Victoria Basin in Tanzania, Master&#39;s thesis, The University of Dodoma, 2012. [Abs] Water quality monitoring and evaluation are important practices for water resources management. However for decades, water quality monitoring and evaluation in developing countries like Tanzania have depended on costly, time- and labor-intensive on-site sampling and data collection and transport to laboratories for evaluation. Emerging technologies like Wireless Sensor Network (WSN) can be used to provide relatively inexpensive, coordinated, intelligent networks allowing a well coordinated and continuous monitoring of water quality. This dissertation investigates the application of WSN in monitoring water quality and propose a low cost water quality monitoring system based on a WSN, which is to be applied to monitor water quality around Lake Victoria basin. Appropriate open source WSN technologies are identified and the proposed network is then analyzed through simulation using NS-2 with the aim of estimating the maximum number of nodes, maximum number of sources nodes and transmit power level that could be used while still achieving a desirable network performance. Using Radio Mobile software, this dissertation has demonstrated that long distant WSN link is possible in Musoma with link margin greater than 10dB and Fresnel zone greater than 0.6F. . |",
          "url": "https://sambaiga.github.io/sambaiga/publications/",
          "relUrl": "/publications/",
          "date": ""
      }
      
  

  
      ,"page6": {
          "title": "Resources",
          "content": "",
          "url": "https://sambaiga.github.io/sambaiga/resources.html",
          "relUrl": "/resources.html",
          "date": ""
      }
      
  

  
  

  

  
  

  

  
      ,"page11": {
          "title": "Talk",
          "content": "",
          "url": "https://sambaiga.github.io/sambaiga/talks/",
          "relUrl": "/talks/",
          "date": ""
      }
      
  

  
  

  
  

  
      ,"page14": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://sambaiga.github.io/sambaiga/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

  
  

}